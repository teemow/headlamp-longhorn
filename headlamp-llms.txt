Directory Structure:

└── ./
    ├── docs
    │   └── development
    │       └── plugins
    │           ├── functionality
    │           │   ├── extending-the-map.md
    │           │   └── index.md
    │           ├── building.md
    │           ├── how-to.md
    │           ├── index.md
    │           └── publishing.md
    └── plugins
        ├── examples
        │   ├── app-menus
        │   │   └── src
        │   │       └── headlamp-plugin.d.ts
        │   ├── change-logo
        │   │   └── src
        │   │       └── headlamp-plugin.d.ts
        │   ├── cluster-chooser
        │   │   └── src
        │   │       └── headlamp-plugin.d.ts
        │   ├── customizing-map
        │   │   └── src
        │   │       └── headlamp-plugin.d.ts
        │   ├── details-view
        │   │   └── src
        │   │       └── headlamp-plugin.d.ts
        │   ├── dynamic-clusters
        │   │   └── src
        │   │       └── headlamp-plugin.d.ts
        │   ├── headlamp-events
        │   │   └── src
        │   │       └── headlamp-plugin.d.ts
        │   ├── pod-counter
        │   │   └── src
        │   │       ├── headlamp-plugin.d.ts
        │   │       └── styles.css
        │   ├── resource-charts
        │   │   └── src
        │   │       ├── headlamp-plugin.d.ts
        │   │       └── types.d.ts
        │   └── sidebar
        │       └── src
        │           └── headlamp-plugin.d.ts
        └── headlamp-plugin
            ├── bin
            │   └── headlamp-plugin.js
            ├── config
            │   ├── .storybook
            │   │   ├── HeadlampTheme.js
            │   │   ├── main.js
            │   │   └── manager.js
            │   ├── storyshots
            │   │   └── storyshots-test.ts
            │   └── setupTests.js
            ├── plugin-management
            │   ├── plugin-management.e2e.js
            │   ├── plugin-management.js
            │   └── plugin-management.test.js
            ├── src
            │   ├── additional.d.ts
            │   ├── ApiProxy.ts
            │   ├── CommonComponents.ts
            │   ├── Crd.ts
            │   ├── index.ts
            │   └── Utils.ts
            ├── template
            │   └── src
            │       └── headlamp-plugin.d.ts
            ├── dependencies-sync.js
            ├── test-headlamp-plugin-published.js
            └── test-headlamp-plugin.js



---
File: /docs/development/plugins/functionality/extending-the-map.md
---

---
title: Extending the Map
sidebar_label: Extending the Map
---

Map view displays cluster resource on a graph. Plugins can extend this graph by adding nodes and edges.

## Nodes, edges and sources

**Node** represents a Kubernetes resource. **Edges** connect different **nodes**, for example ReplicaSet connects to Pods it owns.

<figure>

![Screenshot of a Map with one ReplicaSet node connected to three Pods it owns](./images/map-rs-and-pods.png)

<figcaption>1 ReplicaSet and 3 Pods it owns</figcaption>
</figure>

To add your own nodes and edges you need to define a **Source**

A graph **Source** represents a collection of Nodes and Edges along with name and icon. Source may contain other Sources.

<figure style="text-align: center">

![Screenshot of a Source picker containing various Kubernetes resource sources](./images/source-picker-workloads.png)

<figcaption>Example: "Pods" is a source that contains Nodes for all the Pods in the cluster, "Workloads" is also a source containing other Sources.</figcaption>
</figure>

## Creating and registering a Source

To define a Source create an object with the following structure:

```tsx
const mySource = {
  id: "my-source", // ID of the source should be unique
  label: "My Source", // label will be displayed in source picker
  // you can provide an icon
  icon: (
    <img
      src="https://headlamp.dev/img/favicon.png"
      alt="My Source logo"
      style={{ width: "100%", height: "100%" }}
    />
  ),
  /**
   * useData is a hook that will be called to load nodes and edges for your source
   * You can use hooks here that Headlamp provides to load Kubernetes resources
   * this hook should return an object with nodes and edges or `null` if it's loading
   * it's important that return object is not recreated every time, so useMemo is required
   */
  useData() {
    return useMemo(() => {
      // This would come from kubernetes API but it's hardcoded here as an example
      const myResource = {
        kind: "MyResourceKind",
        metadata: {
          uid: "1234",
          name: "my-test-resource",
          namespace: "test-namespace",
          creationTimestamp: "1234",
        },
      };

      const edges = []; // no edges in this source
      const nodes = [
        {
          id: myResource.metadata.uid, // ID should be unique
          kubeObject: new KubeObject(myResource),
          // Optionally provide a custom details component to be shown when node is selected
          detailsComponent: ({ node }) => {
            return (
              <div>
                <h2>Custom Details View</h2>
                <p>
                  This is a custom details view for:
                  {node.kubeObject.metadata.name}
                </p>
              </div>
            );
          },
        },
      ];

      return { edges, nodes };
    }, []);
  },
};
```

Then to register it call `registerMapSource`

```tsx
registerMapSource(mySource);
```

You'll now see it in the Source picker and the Node on the Map:

<figure style="text-align: center">

![Screenshot of a source picker](./images/source-picker.png)

<figcaption>"My Source" is listed on the bottom. Enabled by default.</figcaption>
</figure>

<figure style="text-align: center">

![Screenshot of a node with a default icon](./images/node-without-an-icon.png)

<figcaption>MyCustomResource Node displayed with default Icon</figcaption>
</figure>

## Node Icons

To add an icon to the Node you need to call `registerKindIcon`.

Note: This is different from the Source icon. One Source may contain multiple different kinds of objects.

```tsx
registerKindIcon("MyCustomResource", {
  // icon is a JSX element
  icon: <img src="https://headlamp.dev/img/favicon.png" />,
});
```

<figure style="text-align: center">

![Screenshot of a node with a custom icon](./images/node-with-an-icon.png)

<figcaption>Node with a custom Icon</figcaption>
</figure>

## Custom Detail Views

When a node is selected on the map, its details are shown in a side panel. By default, if the node represents a Kubernetes resource (has `kubeObject` property), Headlamp will show the standard resource details view.

You can override this behavior by providing a custom details component:

```tsx
const myNode = {
  id: "custom-node",
  label: "Node with custom details",
  detailsComponent: ({ node }) => {
    return (
      <div>
        <h2>Custom Details</h2>
        <p>This is a custom details view for: {node.label}</p>
        {/* You can access any node property here */}
        <pre>{JSON.stringify(node, null, 2)}</pre>
      </div>
    );
  },
};
```

The details component receives the node object as a prop, giving you access to all node properties.

This is useful when you want to:

- Show custom visualizations for your resources
- Display data from external sources alongside Kubernetes resources
- Create interactive detail views specific to your use case



---
File: /docs/development/plugins/functionality/index.md
---

---
title: Plugins Functionality
sidebar_label: Functionality
---

Headlamp's plugins exist to change or add functionality related to
the user interface and experience.

## Plugins Lib

The `@kinvolk/headlamp-plugin` module ships a library
(`@kinvolk/headlamp-plugin/lib`) where all the Headlamp-related development
modules can be found.

The main ones are:

- K8s: Kubernetes related functionality
- Headlamp: To register plugins
- CommonComponents: React components commonly used in the Headlamp UI
- Notification: This module contains two exported members. The first is Notification, a class that can be used to prepare notifications accepted by headlamp. The second is setNotificationsInStore. It's a dispatcher function that accepts a notification object from the Notification class. When called, it brings the notifications from plugin land to the Headlamp ecosystem so that Headlamp can parse the notification and display it.
- Router: To get or generate routes

### Shared Modules

Headlamp ships many common npm modules shared by both the plugins and
Headlamp itself and includes the config files for editors like VS Code
to find them.

These are:

- react
- @iconify-react
- react-redux
- @material-ui/core
- @material-ui/styles
- lodash
- notistack
- recharts

Thus, plugins only need to install dependencies that are not yet provided by Headlamp.
If any dependencies already covered by Headlamp are installed by the plugins, ensure
that they are the same version that Headlamp supports. These will not be bundled when
[building the plugin](../building.md).
Particularly, the mentioned modules will be replaced by their version that's included
in a global object called `pluginLib`.

Older plugin development guides still asked developers to use, e.g., React, in the following
way: `const React: window.pluginLib.React`. But, this is no longer needed.

## Functionality

The plugin registers makes functionality available to plugins in an easy way.

The idea is to make more and more functionality available to plugins. Here is
what we have so far:

### App Bar Action

Show a component in the app bar (in the top right) with
[registerAppBarAction](../../api/plugin/registry/functions/registerappbaraction).

![screenshot of the header showing two actions](../images/podcounter_screenshot.png)

- Example plugin shows [How To Register an App Bar Action](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/pod-counter)
- API reference for [registerAppBarAction](../../api/plugin/registry/functions/registerappbaraction)

### App Logo

Change the logo (at the top left) with
[registerAppLogo](../../api/plugin/registry/functions/registerapplogo).

![screenshot of the logo being changed](../images/change-logo.png)

- Example plugin shows [How To Change The Logo](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/change-logo)
- API reference for [registerAppLogo](../../api/plugin/registry/functions/registerapplogo)

### App Menus

Add menus when Headlamp is running as an app.
[Headlamp.setAppMenu](../../api/plugin/lib/classes/Headlamp#setappmenu)

![screenshot of the logo being changed](../images/app-menus.png)

- Example plugin shows [How To Add App Menus](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/app-menus)
- API reference for [Headlamp.setAppMenu](../../api/plugin/lib/classes/Headlamp#setappmenu)

### Cluster Chooser

Change the Cluster Chooser button (in the middle top of the Headlamp app bar) with
[registerClusterChooser](../../api/plugin/registry/functions/registerclusterchooser).

![screenshot of the cluster chooser button](../images/cluster-chooser.png)

- Example plugin shows [How To Register Cluster Chooser button](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/clusterchooser)
- API reference for [registerClusterChooser](../../api/plugin/registry/functions/registerclusterchooser)

### Details View Header Action

Show a component to the top right area of a detail view
(in the area of the screenshot below that's highlighted as yellow)
[registerDetailsViewHeaderAction](../../api/plugin/registry/functions/registerdetailsviewheaderaction).

![screenshot of the header showing two actions](../images/header_actions_screenshot.png)

- Example plugin shows [How To set a Details View Header Action](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/details-view)
- API reference for [registerDetailsViewHeaderAction](../../api/plugin/registry/functions/registerdetailsviewheaderaction)

### Details View Section

Change sections in cluster resources' details views with [registerDetailsViewSectionsProcessor](../../api/plugin/registry/functions/registerdetailsviewsectionsprocessor). This allows you to remove, add, update, or shuffle sections within details views, including the back link.

Or simply append a component at the bottom of different details views with
[registerDetailsViewSection](../../api/plugin/registry/functions/registerdetailsviewsection).

![screenshot of the appended Details View Section](../images/details-view.jpeg)

- Example plugin shows [How To set a Details View Section](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/details-view)
- API reference for [registerDetailsViewSection](../../api/plugin/registry/functions/registerdetailsviewsection)

### Dynamic Clusters

Set a cluster dynamically, rather than have the backend read it from configuration files.
[Headlamp.setCluster](../../api/plugin/lib/classes/Headlamp.md#setcluster).

- Example plugin shows [How To Dynamically Set a Cluster](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/dynamic-clusters)
- API reference for [Headlamp.setCluster](../../api/plugin/lib/classes/Headlamp.md#setcluster)

### Route

Show a component (in Headlamps main area) at a given URL with
[registerRoute](../../api/plugin/registry/functions/registerroute).

- Example plugin shows [How To Register a Route](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/sidebar), and how to remove a route.
- API reference for [registerRoute](../../api/plugin/registry/functions/registerroute)
- API reference for [registerRouteFilter](../../api/plugin/registry/functions/registerroutefilter)

### Sidebar Item

Add sidebar items (menu on the left) with
[registerSidebarEntry](../../api/plugin/registry/functions/registersidebarentry).
Remove sidebar items with [registerSidebarEntryFilter](../../api/plugin/registry/functions/registersidebarentryfilter).

![screenshot of the sidebar being changed](../images/sidebar.png)

- Example plugin shows [How To add items to the sidebar](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/sidebar), and also how to remove sidebar items.
- API reference for [registerSidebarEntry](../../api/plugin/registry/functions/registersidebarentry)
- API reference for [registerSidebarEntryFilter](../../api/plugin/registry/functions/registersidebarentryfilter)

### Tables

Change what tables across Headlamp show with [registerResourceTableColumnsProcessor](../../api/plugin/registry/functions/registersidebarentry). This allows you to remove, add, update, or shuffle table columns.

![screenshot of the pods list with a context menu added by a plugin](../images/table-context-menu.png)

- Example plugin shows [How to add a context menu to each row in the pods list table](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/tables).
- API reference for [registerResourceTableColumnsProcessor](../../api/plugin/registry/functions/registerresourcetablecolumnsprocessor)

### Headlamp Events

Headlamp has the concept of "Headlamp events". Those are fired when something relevant happens in Headlamp.

React to Headlamp events with [registerHeadlampEventCallback](../../api/plugin/registry/functions/registerheadlampeventcallback).

![screenshot of a snackbar notification when an event occurred](../images/event-snackbar.png)

- Example plugin shows [How to show snackbars for Headlamp events](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/headlamp-events).
- API reference for [registerHeadlampEventCallback](../../api/plugin/registry/functions/registerheadlampeventcallback)

### Plugin Settings

The plugins can have user-configurable settings that can be used to change the behavior of the plugin. The plugin settings can be created using [registerPluginSettings](../../api/plugin/registry/functions/registerpluginsettings).

- Example plugin shows [How to create plugin settings and use them](https://github.com/kubernetes-sigs/headlamp/tree/main/plugins/examples/change-logo)

![screenshot of the plugin settings](../images/plugin-settings.png)



---
File: /docs/development/plugins/building.md
---

---
title: Building and Shipping Plugins
sidebar_label: Building & Shipping
---

This section explains how to start developing a Headlamp plugin and how
to ship it once finished.

## Creating a new plugin

This is how to start a new plugin:

```bash
npx --yes @kinvolk/headlamp-plugin create headlamp-myfancy
cd headlamp-myfancy
npm run start
```

There's some basic code inside src/index.tsx.

Now run Headlamp (the desktop app or the
[development version](../index.md#run-the-code)),
and your plugin should be loaded.

Using the above commands means that Headlamp will **automatically reload**
whenever to make a change to the plugin.

ℹ️ This automatic reload does not happen when running in-cluster,
even if the plugins folder is changed. I.e., if you want to serve
updated plugins, you need to restart the server.

## Code Formatting, Linting, and Type Checking

Your plugin has a few tools built in to help make development easier.

#### Format code with prettier

```bash
npm run format
```

#### Find code lint issues with eslint

```bash
npm run lint
```

Eslint also allows you to try and automatically fix issues.

```bash
npm run lint-fix
```

#### Run the type checker

```bash
npm run tsc
```

#### Run the tests

```bash
npm run test
```

## Building for production

To build the previous plugin example for production, run the following
command:

```bash
cd headlamp-myfancy
npm install
npm run build
```

This will create a file with the bundled plugin in
`headlamp-myfancy/dist/main.js`.

### Building a folder of packages at once

For convienience the `headlamp-plugin build` command can build a
package or folder of packages.

```bash
npx @kinvolk/headlamp-plugin build myplugins/headlamp-myfancy
npx @kinvolk/headlamp-plugin build myplugins
```

## Shipping and Deploying Plugins

Once a plugin is ready to be shipped (built for production), it needs to
be placed in a "plugins directory" for Headlamp to load it.

For example, if we have built 3 plugins called MyPlugin1, MyPlugin2, and
MyPlugin3, they should be added to a directory in the following structure:

```
.plugins/
  MyPlugin1/
    main.js
  MyPlugin2/
    main.js
  MyPlugin3/
    main.js
```

If our plugins are placed in `myplugins`, we can conveniently create that
folder with the following command:

```bash
npx @kinvolk/headlamp-plugin extract ./myplugins /path/to/.plugins
```

This also works individually (for each plugin):

```bash
npx @kinvolk/headlamp-plugin extract ./myplugins/MyPlugin1 /path/to/./plugins
```

### In-cluster deployment with plugins

For in-cluster Headlamp deployments, when running Headlamp's server,
the `-plugin-dir` option should point to the directory:

```bash
./headlamp-server -plugins-dir=.plugins
```

### Using plugins on the desktop version

The Headlamp desktop app will look for the plugins directory (in the format
mentioned above). This will be either under the user's Headlamp configuration folder
or within the current folder as `.plugins` if the former doesn't exist.

### Bundling plugins with desktop version

To build a Headlamp app with a set of plugins, first extract some plugins
into the .plugins folder in the root of the "headlamp" repo.

```bash
cd plugins/examples/pod-counter
npm install
npm run build
cd ../..

mkdir .plugins
npx @kinvolk/headlamp-plugin extract ./plugins/examples/ ./.plugins
ls -la .plugins
make app-linux
```

For more on how to extract files into there see "Shipping and Deploying Plugins" above.

### More on making a headlamp container image including plugins

See the blog post
"[Get up to speed deploying Headlamp with plugins](https://headlamp.dev/blog/2022/10/20/best-practices-for-deploying-headlamp-with-plugins)"
for more information on building a container image with your plugins.

## Writing storybook stories

What is a storybook story?

From <https://storybook.js.org/docs/web-components/get-started/introduction>

> Storybook is a tool for UI development. It makes development faster and
> easier by isolating components. This allows you to work on one component
> at a time. You can develop entire UIs without needing to start up a
> complex dev stack, force certain data into your database,
> or navigate around your application.

See an example in your browser:

```bash
$ cd plugins/examples/pod-counter
$ ls src
headlamp-plugin.d.ts  index.tsx  Message.stories.tsx  Message.tsx
$ npm install
$ npm run storybook
```

Your browser should open and show you a Message component with three
different states the component can be in.

Note that there is a Message.stories.tsx to go along with the Message.tsx
which has the `<Message>` component defined within it. See that file for an
example of how to write a story.

### Snapshot testing

Another benefit of writing storybook stories is that they can act as
unit tests for regression testing. Storyshots will save snapshots
of html for the different states that a component can be in. See the
[Snapshot tests](https://storybook.js.org/docs/react/writing-tests/snapshot-testing)
guide in the storybook documentation for more information.

This is in addition to the benefit of making sure your components can be
manually tested and developed quickly in isolation.

See the [storybook documentation](https://storybook.js.org/docs/) for full
details on storybook.

## Running tests on a github action

A workflow for testing your plugin on github with actions.

Below is based on the [Building and testing Node.js](https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs) docs from GitHub.

Place this in a file named something like `.github/workflows/headlamp-plugin-github-workflow.yaml` in the root of your repo.

```yaml
name: Headlamp plugin linting, type checking, and testing

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: ./your-folder-of-plugins

    strategy:
      matrix:
        node-version: [18.x]

    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - run: npx @kinvolk/headlamp-plugin lint .
      - run: npx @kinvolk/headlamp-plugin format --check .
      - run: npx @kinvolk/headlamp-plugin tsc .
      - run: npx @kinvolk/headlamp-plugin test .
      - run: npx @kinvolk/headlamp-plugin build .
```

Please see the GitHub documentation for further details on workflows and actions.

## Upgrading package

There's a command that handles much of the upgrading of plugins to the latest headlamp-plugin version. This upgrade command also audits packages, formats code, lints, and type checks.

Additionally, this handles some code changes needed for plugins. For example, it handles running the material-ui 4 to mui 5 'codemod' code changes and creates missing configuration added in different versions of headlamp-plugin.

Testing is necessary after running the upgrade command.
Of course, make sure you have a backup of your plugin folder before running it.

```bash
npx @kinvolk/headlamp-plugin upgrade --headlamp-plugin-version=latest your-plugin-folder
```



---
File: /docs/development/plugins/how-to.md
---

---
title: How to create a Plugin
---

This section will walk you through basic plugin development.

## Types

If you are using TypeScript to develop the plugin, the
`@kinvolk/headlamp-plugin` package ships some type declarations in
`@kinvolk/headlamp-plugin/types`. Please note that the whole external
plugin mechanics are still in an early development phase. Thus, only the
actual type declarations (and not the corresponding code) are shipped in this
package.

## Hello Kubernetes

The following example will show basic plugin declaration and registration
in a file that should match the `src/index.tsx` structure explained in the
[building](./building) section.

```tsx title="/src/index.tsx"
import { registerAppBarAction } from "@kinvolk/headlamp-plugin/lib";
registerAppBarAction(<span>Hello Kubernetes</span>);
```

## Plugin Example

Let's create a plugin that just gets the number of pods in the cluster and
displays that information in the top bar (i.e. registers an "app bar action").

```tsx title="/src/index.tsx"
import { K8s, registerAppBarAction } from '@kinvolk/headlamp-plugin/lib';
import { Typography } from '@mui/material';

function PodCounter() {
  const [pods, error]: K8s.ResourceClasses.Pod.useList();
  const msg: pods === null ? 'Loading…' : pods.length.toString();

  return (
    <Typography color="textPrimary" sx={{fontStyle: 'italic'}}>
      {!error ? `# Pods: ${msg}` : 'Uh, pods!?'}
    </Typography>
  );
}

registerAppBarAction(<PodCounter />);
```

Here is the result, running Headlamp with this plugin and using with a Minikube cluster:

![screenshot showing a label on the top bar with the number of pods available](./images/podcounter_screenshot.png)

Please refer to the [functionality](./functionality.md) section for learning about
the different functionality that is available to plugins by the registry.



---
File: /docs/development/plugins/index.md
---

---
title: Plugins
sidebar_position: 6
---

Plugins are one of the key features of Headlamp. They allow you to change how and what information is displayed and may serve various use cases. The plugins system aims to allow vendors to add features to Headlamp without having to maintain a fork of the project.

## Using plugins

Headlamp looks for plugins in different places.
It looks at the Headlamp's configuration folder first:

On a Mac and Linux desktop, the plugins folder is by default:
`$HOME/.config/Headlamp/plugins`

On Windows, it is by default:
`$APPDATA/Headlamp/Config/plugins`

In the plugins directory, plugins should be in the following format:

```
MyPlugin1/
    main.js
MyPlugin2/
    main.js
MyPlugin3/
    main.js
```

See the [shipping & deploying plugins](./building.md#shipping-and-deploying-plugins) section
for more details.

## Developing Plugins

Plugins are meant to be build and shipped out-of-tree (i.e., outside of the project and loaded by
Headlamp). This is opposed to managing the plugins' code within the Headlamp
project or within a Headlamp fork. Such a setup would require always
rebuilding/maintaining Headlamp when changing a plugin.

Learn [how to create a Headlamp plugin](./building.md).



---
File: /docs/development/plugins/publishing.md
---

---
title: Publishing Plugins
sidebar_label: Publishing
---

Headlamp at its core does not have a way to make plugins discoverable or to list them to the user. However, the desktop version of Headlamp ships with the [Plugin Catalog](URL_FOR_PLUGIN) plugin, which does provide a way for users to list Headlamp plugins from [ArtifactHub](https://artifacthub.io), install and remove them.

This section of the docs is a guide for how to publish a Headlamp plugin to ArtifactHub.

## Prerequisites

* A GitHub repository containing your Headlamp plugin code. See the [building](./building.md) section to learn how to implement a Headlamp plugin.

## Step 1: Create an ArtifactHub repository file

ArtifactHub will need to know that you own the repository you set up for your plugins (this is done in a later step in this guide). So start by creating a file called `artifacthub-repo.yml` at the root of your GitHub repository with the following content:

```yaml
owners:
- name: <Your Name>
  email: <your-email@example.com>
```

Replace `<Your Name>` and `<your-email@example.com>` with your name and email, respectively.

## Step 2: Build and Release Your Plugin on GitHub

1. Move to your plugin’s folder, then run the following command:
  ```bash
  npm install
  npm run build
  npm run package
  ```
  It will create a tarball of the plugin in a Headlamp-accepted format and also print the checksum of the tarball that we will use in the next step.

2. Create a new release on GitHub for your plugin.

3. Tag the release with a semantic version number (e.g., v1.0.0).

4. Upload the built plugin files as assets to this release.

For detailed instructions on creating a new release, refer to the [GitHub documentation](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository).

:::info
For security reasons, Headlamp allows the download of plugins exclusively from GitHub, GitLab, and BitBucket. While this may change in the future, if you need your plugins to be downloaded from somewhere else, please [let us know](https://github.com/kubernetes-sigs/headlamp/issues).

Also, by default the Plugin Catalog only shows plugins marked as official in ArtifactHub, or allow-listed by Headlamp. Users can override this behavior and make Headlamp show all the plugins by switching off the "Only official plugins" setting for the Plugin Catalog. Read more at the [Plugin Catalog README](https://github.com/headlamp-k8s/plugins/tree/main/plugin-catalog#readme).
:::

## Step 3: Create an ArtifactHub package for the plugin

ArtifactHub needs to detect that you have a Headlamp plugin in your repository, and read the data about it. For that, we need an ArtifactHub package file in the repo for each plugin we have. For that, create an `artifacthub-pkg.yml` file in the root of your repository  with the following content:

```yaml
version: 0.1.0
name: <Your Plugin Name>
displayName: <Your Plugin Display Name>
createdAt: "2024-07-18T05:35:50Z"
logoURL: <Your Plugin Logo URL>
description: <Your Plugin Description>
annotations:
  headlamp/plugin/archive-url: <Your Plugins Archive URL>
  headlamp/plugin/archive-checksum: <Checksum of the tarball>
  headlamp/plugin/version-compat: <Version>
  headlamp/plugin/distro-compat: <Compatibility of your plugin>
```

Replace the placeholders with appropriate values. For more information, refer to the [Artifact Hub documentation](https://artifacthub.io/docs/topics/annotations/headlamp/). A sample configuration can be found [here](https://github.com/headlamp-k8s/plugins/blob/main/opencost/artifacthub-pkg.yml).

## Step 4: Push Changes to GitHub

Commit and push the `artifacthub-repo.yml` and `artifacthub-pkg.yml` files to your GitHub repository:

```sh
git add artifacthub-repo.yml artifacthub-pkg.yml
git commit -m "Add Artifact Hub configuration"
git push origin main
```

## Step 5: Register your repository in Artifact Hub

1. Navigate to [Artifact Hub](https://artifacthub.io/).
2. Sign in or create an account.
3. Click on "Add" in your Control Panel.
4. Select "Headlamp plugin" as the repository kind.
5. Enter the Name and GitHub repository URL.
6. Click "Add" to submit.

**Control Panel part of ArtifactHub:**
![Screenshot of the Control Panel part of ArtifactHub](./images/plugin-repo-add-repo-button.png)

**Adding a repo in ArtifactHub:**
![Screenshot of adding a repo in ArtifactHub](./images/plugin-guide-add-repo.png)

Artifact Hub will scan your repository. If everything is configured correctly, your plugin will be listed.

## Conclusion

Congratulations! You've successfully published your Headlamp plugin to Artifact Hub. Your plugin is now discoverable and available for others to use*. For more detailed information on configurations and best practices, refer to the [Artifact Hub documentation](https://artifacthub.io/docs/topics/repositories/headlamp-plugins) and the [Headlamp plugin development guide](https://headlamp.dev/docs/latest/development/plugins/).

**Plugin example in the Plugin Catalog:**
![Screenshot of a plugin in the Plugin Catalog](./images/plugin-on-plugin-catalog.png)



---
File: /plugins/examples/app-menus/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/change-logo/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/cluster-chooser/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/customizing-map/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/details-view/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/dynamic-clusters/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/headlamp-events/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/pod-counter/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/pod-counter/src/styles.css
---

.random_class_name {
  color: #000;
}



---
File: /plugins/examples/resource-charts/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/examples/resource-charts/src/types.d.ts
---

declare module '@mui/material' {
  import { Theme } from '@mui/material/styles';
  import { ElementType, ReactNode } from 'react';

  export function useTheme(): Theme;

  export interface BoxProps {
    p?: number;
    children?: ReactNode;
  }

  export const Box: ElementType<BoxProps>;
  export const Paper: ElementType;
}

declare module '@mui/material/styles' {
  export interface Theme {
    palette: {
      error: {
        main: string;
      };
      [key: string]: any;
    };
  }
}



---
File: /plugins/examples/sidebar/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/headlamp-plugin/bin/headlamp-plugin.js
---

#!/usr/bin/env node
// @ts-check
'use strict';

const crypto = require('crypto');
const fs = require('fs-extra');
const envPaths = require('env-paths');
const os = require('os');
const path = require('path');
const resolve = path.resolve;
const child_process = require('child_process');
const validate = require('validate-npm-package-name');
const yargs = require('yargs/yargs');
const headlampPluginPkg = require('../package.json');
const PluginManager = require('../plugin-management/plugin-management').PluginManager;
const { table } = require('table');
const tar = require('tar');

// ES imports
const viteCopyPluginPromise = import('vite-plugin-static-copy');
const viteConfigPromise = import('../config/vite.config.mjs');
const vitePromise = import('vite');

/**
 * Creates a new plugin folder.
 *
 * Copies the files within template, and modifies a couple.
 * Then runs npm install inside of the folder.
 *
 * @param {string} name - name of package and output folder.
 * @param {boolean} link - if we link @kinvolk/headlamp-plugin for testing
 * @returns {0 | 1 | 2 | 3} Exit code, where 0 is success, 1, 2, and 3 are failures.
 */
function create(name, link) {
  const dstFolder = name;
  const templateFolder = path.resolve(__dirname, '..', 'template');
  const indexPath = path.join(dstFolder, 'src', 'index.tsx');
  const packagePath = path.join(dstFolder, 'package.json');
  const readmePath = path.join(dstFolder, 'README.md');

  if (fs.existsSync(name)) {
    console.error(`"${name}" already exists, not initializing`);
    return 1;
  }

  const nameValid = validate(name);
  if (!nameValid.validForNewPackages) {
    console.error(`Invalid package name:"${name}":, not initializing`);
    console.error(nameValid.errors);
    return 2;
  }

  console.log(`Creating folder :${dstFolder}:`);

  fs.copySync(templateFolder, dstFolder, {
    errorOnExist: true,
    overwrite: false,
  });

  function replaceFileVariables(path) {
    fs.writeFileSync(
      path,
      fs
        .readFileSync(path, 'utf8')
        .split('$${name}')
        .join(name)
        .split('$${headlamp-plugin-version}')
        .join(headlampPluginPkg.version)
        .split('$${eslint-config-version}')
        .join(headlampPluginPkg.dependencies['@headlamp-k8s/eslint-config'])
    );
  }

  replaceFileVariables(packagePath);
  replaceFileVariables(indexPath);
  replaceFileVariables(readmePath);

  // This can be used to make testing locally easier.
  if (link) {
    console.log('Linking @kinvolk/headlamp-plugin');
    child_process.spawnSync('npm', ['link', '@kinvolk/headlamp-plugin'], {
      cwd: dstFolder,
    });
  }

  console.log('Installing dependencies...');
  // Run npm install.
  try {
    child_process.execSync('npm install', {
      stdio: 'inherit',
      cwd: dstFolder,
      encoding: 'utf8',
    });
  } catch (e) {
    console.error(
      `Problem running npm install inside of "${dstFolder}" abs: "${resolve(dstFolder)}"`
    );
    return 3;
  }

  // This can be used to make testing locally easier.
  if (link) {
    // Seems to require linking again with npm 7+
    console.log('Linking @kinvolk/headlamp-plugin');
    child_process.spawnSync('npm', ['link', '@kinvolk/headlamp-plugin'], {
      cwd: dstFolder,
    });
  }

  console.log(`"${dstFolder}" created.`);
  console.log(`1) Run the Headlamp app (so the plugin can be used).`);
  console.log(`2) Open ${dstFolder}/src/index.tsx in your editor.`);
  console.log(`3) Start development server of the plugin watching for plugin changes.`);
  console.log(`  cd "${dstFolder}"\n  npm run start`);
  console.log(`4) See the plugin inside Headlamp.`);

  return 0;
}

/**
 * extract copies folders of packages in the form:
 *   packageName/dist/main.js to packageName/main.js
 *   packageName/package.json to packageName/package.json
 *
 * @param {string} pluginPackagesPath - can be a package or a folder of packages.
 * @param {string} outputPlugins - folder where the plugins are placed.
 * @param {boolean} logSteps - whether to print the steps of the extraction (true by default).
 * @returns {0 | 1} Exit code, where 0 is success, 1 is failure.
 */
function extract(pluginPackagesPath, outputPlugins, logSteps = true) {
  if (!fs.existsSync(pluginPackagesPath)) {
    console.error(`"${pluginPackagesPath}" does not exist. Not extracting.`);
    return 1;
  }
  if (!fs.existsSync(outputPlugins)) {
    if (logSteps) {
      console.log(`"${outputPlugins}" did not exist, making folder.`);
    }
    fs.mkdirSync(outputPlugins);
  }

  /**
   * pluginPackagesPath is a package folder, not a folder of packages.
   */
  function extractPackage() {
    if (fs.existsSync(path.join(pluginPackagesPath, 'dist', 'main.js'))) {
      const distPath = path.join(pluginPackagesPath, 'dist');
      const trimmedPath =
        pluginPackagesPath.slice(-1) === path.sep
          ? pluginPackagesPath.slice(0, -1)
          : pluginPackagesPath;
      const folderName = trimmedPath.split(path.sep).splice(-1)[0];
      const plugName = path.join(outputPlugins, folderName);

      fs.ensureDirSync(plugName);

      const files = fs.readdirSync(distPath);
      files.forEach(file => {
        const srcFile = path.join(distPath, file);
        const destFile = path.join(plugName, file);
        console.log(`Copying "${srcFile}" to "${destFile}".`);
        fs.copyFileSync(srcFile, destFile);
      });

      const inputPackageJson = path.join(pluginPackagesPath, 'package.json');
      const outputPackageJson = path.join(plugName, 'package.json');
      console.log(`Copying "${inputPackageJson}" to "${outputPackageJson}".`);
      fs.copyFileSync(inputPackageJson, outputPackageJson);

      return true;
    }
    return false;
  }

  function extractFolderOfPackages() {
    const folders = fs.readdirSync(pluginPackagesPath, { withFileTypes: true }).filter(fileName => {
      return (
        fileName.isDirectory() &&
        fs.existsSync(path.join(pluginPackagesPath, fileName.name, 'dist', 'main.js'))
      );
    });

    folders.forEach(folder => {
      const distPath = path.join(pluginPackagesPath, folder.name, 'dist');
      const plugName = path.join(outputPlugins, folder.name);

      fs.ensureDirSync(plugName);

      const files = fs.readdirSync(distPath);
      files.forEach(file => {
        const srcFile = path.join(distPath, file);
        const destFile = path.join(plugName, file);
        console.log(`Copying "${srcFile}" to "${destFile}".`);
        fs.copyFileSync(srcFile, destFile);
      });

      const inputPackageJson = path.join(pluginPackagesPath, folder.name, 'package.json');
      const outputPackageJson = path.join(plugName, 'package.json');
      console.log(`Copying "${inputPackageJson}" to "${outputPackageJson}".`);
      fs.copyFileSync(inputPackageJson, outputPackageJson);
    });
    return folders.length !== 0;
  }

  if (!(extractPackage() || extractFolderOfPackages())) {
    console.error(`"${pluginPackagesPath}" does not contain packages. Not extracting.`);
    return 1;
  }

  return 0;
}

/**
 * Calculate the checksum of a file.
 *
 * @param {*} filePath
 * @returns
 */
async function calculateChecksum(filePath) {
  try {
    const fileBuffer = await fs.readFile(filePath);
    const hashSum = crypto.createHash('sha256');
    hashSum.update(fileBuffer);
    const hex = hashSum.digest('hex');
    return hex;
  } catch (error) {
    console.error('Error calculating checksum:', error);
    throw error; // Rethrow the error if you want to handle it further up the call stack
  }
}

/**
 * Copy extra files specified in package.json to the dist folder
 *
 * @param {string} [packagePath='.'] - Path to the package root containing package.json
 * @returns {Promise<void>}
 */
async function copyExtraDistFiles(packagePath = '.') {
  try {
    const packageJsonPath = path.join(packagePath, 'package.json');
    if (!fs.existsSync(packageJsonPath)) {
      return; // No package.json, nothing to do
    }

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    if (!packageJson.headlamp || !packageJson.headlamp.extraDist) {
      return; // No extra files to copy
    }

    const extraDist = packageJson.headlamp.extraDist;
    const distFolder = path.resolve(packagePath, 'dist');

    // Create dist folder if it doesn't exist (although it should by this point)
    if (!fs.existsSync(distFolder)) {
      fs.mkdirSync(distFolder, { recursive: true });
    }

    // Process all entries in extraDist
    for (const [target, source] of Object.entries(extraDist)) {
      const targetPath = path.join(distFolder, target);
      const sourcePath = path.resolve(packagePath, source);

      // Skip if source doesn't exist
      if (!fs.existsSync(sourcePath)) {
        console.warn(`Warning: extraDist source "${sourcePath}" does not exist, skipping.`);
        continue;
      }

      // Create target directory if needed
      fs.mkdirSync(path.dirname(targetPath), { recursive: true });

      // Copy based on whether it's a directory or file
      const sourceStats = fs.statSync(sourcePath);
      if (sourceStats.isDirectory()) {
        console.log(`Copying extra directory "${sourcePath}" to "${targetPath}"`);
        fs.copySync(sourcePath, targetPath);
      } else {
        console.log(`Copying extra file "${sourcePath}" to "${targetPath}"`);
        fs.copyFileSync(sourcePath, targetPath);
      }
    }

    console.log('Successfully copied extra dist files');
  } catch (error) {
    console.error('Error copying extra dist files:', error);
  }
}

/**
 * Creates a tarball of the plugin package. The tarball is placed in the outputFolderPath.
 * It moves files from:
 *   packageName/dist/main.js to packageName/main.js
 *   packageName/package.json to packageName/package.json
 * And then creates a tarball of the resulting folder.
 *
 * @param {string} pluginDir - path to the plugin package.
 * @param {string} outputDir - folder where the tarball is placed.
 *
 * @returns {0 | 1} Exit code, where 0 is success, 1 is failure.
 */
async function createArchive(pluginDir, outputDir) {
  const pluginPath = path.resolve(pluginDir);
  if (!fs.existsSync(pluginPath)) {
    console.error(`Error: "${pluginPath}" does not exist. Not creating archive.`);
    return 1;
  }

  // Extract name + version from plugin's package.json
  const packageJsonPath = path.join(pluginPath, 'package.json');
  let packageJson = '';
  try {
    packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
  } catch (e) {
    console.error(`Error: Failed to read package.json from "${pluginPath}". Not creating archive.`);
    return 1;
  }

  const sanitizedName = packageJson.name.replace(/@/g, '').replace(/\//g, '-');
  const tarballName = `${sanitizedName}-${packageJson.version}.tar.gz`;

  const outputFolderPath = path.resolve(outputDir);
  const tarballPath = path.join(outputFolderPath, tarballName);

  if (!fs.existsSync(outputFolderPath)) {
    console.log(`"${outputFolderPath}" did not exist, making folder.`);
    fs.mkdirSync(outputFolderPath, { recursive: true });
  } else if (fs.existsSync(tarballPath)) {
    console.error(`Error: Tarball "${tarballPath}" already exists. Not creating archive.`);
    return 1;
  }

  // Create temporary folder
  const tempFolder = fs.mkdtempSync(path.join(os.tmpdir(), 'headlamp-plugin-'));

  // Make sure any extraDist files are in the dist folder before extraction
  await copyExtraDistFiles(pluginPath);

  if (extract(pluginPath, tempFolder, false) !== 0) {
    console.error(
      `Error: Failed to extract plugin package to "${tempFolder}". Not creating archive.`
    );
    return 1;
  }

  const folderName = path.basename(pluginPath);

  // Create tarball
  await tar.c(
    {
      gzip: true,
      file: tarballPath,
      cwd: tempFolder,
    },
    [folderName]
  );

  // Remove temporary folder
  fs.rmSync(tempFolder, { recursive: true });

  console.log(`Created tarball: "${tarballPath}".`);

  // Print sha256 checksum for convenience
  const checksum = await calculateChecksum(tarballPath);
  console.log(`Tarball checksum (sha256): ${checksum}`);

  return 0;
}

/**
 * Start watching for changes, and build again if there are changes.
 * @returns {Promise<number>} Exit code, where 0 is success.
 */
async function start() {
  /**
   * Copies the built plugin to the app config folder ~/.config/Headlamp/plugins/
   *
   * Adds a webpack config plugin for copying the folder.
   */
  async function copyToPluginsFolder(viteConfig) {
    const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));

    // @todo: should the whole package name be used here,
    //    and the load be fixed to use? What about namespace packages?
    const packageName = packageJson.name.split('/').splice(-1)[0];
    const paths = envPaths('Headlamp', { suffix: '' });
    const configDir = fs.existsSync(paths.data) ? paths.data : paths.config;

    const { viteStaticCopy } = await viteCopyPluginPromise;

    viteConfig.plugins.push(
      viteStaticCopy({
        targets: [
          {
            src: './dist/*',
            dest: path.join(configDir, 'plugins', packageName),
          },
          {
            src: './package.json',
            dest: path.join(configDir, 'plugins', packageName),
          },
        ],
      })
    );
  }

  /**
   * Inform if @kinvolk/headlamp-plugin is outdated.
   */
  async function informIfOutdated() {
    console.log('Checking if @kinvolk/headlamp-plugin is up to date...');
    child_process.exec('npm outdated --json', (error, stdout) => {
      if (error) {
        // npm outdated exit codes 1 when something is not up to date.
        const result = stdout.toString();
        const outdated = JSON.parse(result);
        if ('@kinvolk/headlamp-plugin' in outdated) {
          const url = `https://github.com/kubernetes-sigs/headlamp/releases`;
          console.warn(
            '    @kinvolk/headlamp-plugin is out of date. Run the following command to upgrade \n' +
              `    See release notes here: ${url}` +
              '    npx @kinvolk/headlamp-plugin upgrade'
          );
          return;
        }
      }
    });
  }

  setTimeout(() => {
    informIfOutdated().catch(error => {
      console.error('Error checking if @kinvolk/headlamp-plugin is up to date:', error);
    });
  }, 500);

  const config = (await viteConfigPromise).default;
  const vite = await vitePromise;

  if (config.build) {
    config.build.watch = {};
    config.build.sourcemap = 'inline';
  }

  // Add file copy hook to be executed after each build
  if (config.plugins) {
    config.plugins.push({
      name: 'headlamp-copy-extra-dist',
      buildEnd: async () => {
        await copyExtraDistFiles();
      },
    });
  }

  // Then add the plugins from copyToPluginsFolder which includes ViteStaticCopy
  await copyToPluginsFolder(config);

  try {
    await vite.build(config);
  } catch (e) {
    console.error(e);
    console.error('Failed to start watching for changes.');
    return 1;
  }

  return 0;
}

/**
 * Run script on a plugin package or folder of plugin packages.
 *
 * @param packageFolder {string} - folder where the package, or folder of packages is.
 * @param scriptName {string} - name of the script to run.
 * @param cmdLine {string} - command line to run.
 * @param env {object} - environment variables to run the command with.
 * @returns {0 | 1} - Exit code, where 0 is success, 1 is failure.
 */
function runScriptOnPackages(packageFolder, scriptName, cmdLine, env) {
  if (!fs.existsSync(packageFolder)) {
    console.error(`"${packageFolder}" does not exist. Not ${scriptName}-ing.`);
    return 1;
  }

  const oldCwd = process.cwd();

  const runOnPackageReturn = {
    success: 0,
    notThere: 1,
    issue: 2,
  };

  function runOnPackage(folder) {
    if (!fs.existsSync(path.join(folder, 'package.json'))) {
      return runOnPackageReturn.notThere;
    }

    process.chdir(folder);

    if (!fs.existsSync('node_modules')) {
      console.log(`No node_modules in "${folder}" found. Running npm install...`);

      try {
        child_process.execSync('npm install', {
          stdio: 'inherit',
          encoding: 'utf8',
        });
      } catch (e) {
        console.error(`Problem running 'npm install' inside of "${folder}"\r\n`);
        process.chdir(oldCwd);
        return runOnPackageReturn.issue;
      }
      console.log(`Finished npm install.`);
    }

    // See if the cmd is in the:
    // - package/node_modules/.bin
    // - package/../node_modules/.bin
    // - the npx node_modules/.bin
    // If not, just use the original cmdLine and hope for the best :)
    let cmdLineToUse = cmdLine;
    const scriptCmd = cmdLine.split(' ')[0];
    const scriptCmdRest = cmdLine.split(' ').slice(1).join(' ');

    const nodeModulesBinCmd = path.join('node_modules', '.bin', scriptCmd);
    const upNodeModulesBinCmd = path.join('../', nodeModulesBinCmd);

    // When run as npx, find it in the node_modules npx uses
    const headlampPluginBin = fs.realpathSync(process.argv[1]);
    const npxBinCmd = path.join(
      path.dirname(headlampPluginBin),
      '..',
      '..',
      '..',
      '..',
      nodeModulesBinCmd
    );

    if (fs.existsSync(nodeModulesBinCmd)) {
      cmdLineToUse = nodeModulesBinCmd + ' ' + scriptCmdRest;
    } else if (fs.existsSync(upNodeModulesBinCmd)) {
      cmdLineToUse = upNodeModulesBinCmd + ' ' + scriptCmdRest;
    } else if (fs.existsSync(npxBinCmd)) {
      cmdLineToUse = npxBinCmd + ' ' + scriptCmdRest;
    } else {
      console.warn(
        `"${scriptCmd}" not found in "${resolve(nodeModulesBinCmd)}" or "${resolve(
          upNodeModulesBinCmd
        )}" or "${resolve(npxBinCmd)}".`
      );
    }

    console.log(`"${folder}": ${scriptName}-ing, :${cmdLineToUse}:...`);

    try {
      child_process.execSync(cmdLineToUse, {
        stdio: 'inherit',
        encoding: 'utf8',
        env: { ...process.env, ...(env || {}) },
      });
    } catch (e) {
      console.error(`Problem running ${scriptName} inside of "${folder}"\r\n`);
      process.chdir(oldCwd);
      return runOnPackageReturn.issue;
    }

    console.log(`Done ${scriptName}-ing: "${folder}".\r\n`);
    process.chdir(oldCwd);
    return runOnPackageReturn.success;
  }

  function runOnFolderOfPackages(packageFolder) {
    const folders = fs.readdirSync(packageFolder, { withFileTypes: true }).filter(fileName => {
      return (
        fileName.isDirectory() &&
        fs.existsSync(path.join(packageFolder, fileName.name, 'package.json'))
      );
    });

    if (folders.length === 0) {
      return {
        error: runOnPackageReturn.notThere,
        failedFolders: [],
      };
    }

    const errorFolders = folders.map(folder => {
      const folderToProcess = path.join(packageFolder, folder.name);
      return {
        error: runOnPackage(folderToProcess),
        folder: folderToProcess,
      };
    });
    const failedErrorFolders = errorFolders.filter(
      errFolder => errFolder.error !== runOnPackageReturn.success
    );

    if (failedErrorFolders.length === 0) {
      return {
        error: runOnPackageReturn.success,
        failedFolders: [],
      };
    }
    return {
      error: runOnPackageReturn.issue,
      failedFolders: failedErrorFolders.map(errFolder => path.basename(errFolder.folder)),
    };
  }

  const exitCode = runOnPackage(packageFolder);

  if (exitCode === runOnPackageReturn.notThere) {
    const folderErr = runOnFolderOfPackages(packageFolder);
    if (folderErr.error === runOnPackageReturn.notThere) {
      console.error(
        `"${resolve(packageFolder)}" does not contain a package or packages. Not ${scriptName}-ing.`
      );
      return 1; // failed
    } else if (folderErr.error === runOnPackageReturn.issue) {
      console.error(
        `Some in "${resolve(packageFolder)}" failed. Failed folders: ${folderErr.failedFolders.join(
          ', '
        )}`
      );
      return 1; // failed
    }
  }

  return exitCode > 0 ? 1 : 0;
}

/**
 * Build the plugin package or folder of packages for production.
 *
 * @param packageFolder {string} - folder where the package, or folder of packages is.
 * @returns {Promise<0 | 1>} Exit code, where 0 is success, 1 is failure.
 */
async function build(packageFolder) {
  if (!fs.existsSync(packageFolder)) {
    console.error(`"${packageFolder}" does not exist. Not building.`);
    return 1;
  }

  const oldCwd = process.cwd();

  async function buildPackage(folder) {
    if (!fs.existsSync(path.join(folder, 'package.json'))) {
      return false;
    }

    process.chdir(folder);
    console.log(`Building "${folder}" for production...`);
    const config = await viteConfigPromise;
    const vite = await vitePromise;
    try {
      await vite.build(config.default);

      // Copy extra dist files after successful build
      await copyExtraDistFiles('.');

      console.log(`Finished building "${folder}" for production.`);
    } catch (e) {
      console.error(e);
      console.error(`Failed to build "${folder}" for production.`);
      process.exit(1);
    }

    process.chdir(oldCwd);
    return true;
  }

  function buildFolderOfPackages() {
    const folders = fs.readdirSync(packageFolder, { withFileTypes: true }).filter(fileName => {
      return (
        fileName.isDirectory() &&
        fs.existsSync(path.join(packageFolder, fileName.name, 'package.json'))
      );
    });

    folders.forEach(folder => {
      const folderToBuild = path.join(packageFolder, folder.name);
      if (!buildPackage(folderToBuild)) {
        console.error(`"${folderToBuild}" does not contain a package. Not building.`);
      }
    });
    return folders.length !== 0;
  }

  if (!(buildPackage(packageFolder) || buildFolderOfPackages())) {
    console.error(`"${packageFolder}" does not contain a package or packages. Not building.`);
  }

  return 0;
}

/**
 * Format plugin code with prettier. Format the plugin package or folder of packages.
 *
 * @param packageFolder {string} - folder where the package, or folder of packages is.
 * @param check {boolean} - if true, check if the code is checked for formatting, but don't format it.
 * @returns {0 | 1} Exit code, where 0 is success, 1 is failure.
 */
function format(packageFolder, check) {
  const cmdLine = check
    ? `prettier --config package.json --check src`
    : 'prettier --config package.json --write --cache src';
  return runScriptOnPackages(packageFolder, 'format', cmdLine, {});
}

/**
 * Use `npm outdated` to find which dependencies are not up to date.
 *
 * @returns a dict keyed by package name
 *
 * @see https://docs.npmjs.com/cli/v8/commands/npm-outdated
 *
 * #### Example
 * ```js
 *  {
 *    "@kinvolk/headlamp-plugin": {
 *      "current": "0.5.0",
 *      "wanted": "0.5.1",
 *      "latest": "0.5.1",
 *      "dependent": "pod-counter",
 *      "location": "/home/rene/dev/headlamp/plugins/examples/pod-counter/node_modules/@kinvolk/headlamp-plugin"
 *    }
 *  }
 * ```
 *
 * #### Example: Nothing needs updating?
 * ```js
 *  {}
 * ```
 */
function getNpmOutdated() {
  let result = null;

  try {
    result = child_process.execSync('npm outdated --json', {
      encoding: 'utf8',
    });
  } catch (error) {
    // npm outdated exit codes 1 when something is not up to date.
    result = error.stdout.toString();
  }
  return JSON.parse(result);
}

/**
 * Upgrade package automatically, updating headlamp-plugin version.
 *
 * In the future this could be used for other upgrade tasks.
 *
 * @param packageFolder {string} - folder where the package, or folder of packages is.
 * @parm skipPackageUpdates {boolean} - do not upgrade packages if true.
 * @param headlampPluginVersion {string} - tag or version of headlamp-plugin to upgrade to.
 * @returns {0 | 1} Exit code, where 0 is success, 1 is failure.
 */
function upgrade(packageFolder, skipPackageUpdates, headlampPluginVersion) {
  /**
   * Files from the template might not be there.
   *
   * Either because they created the package themselves,
   *   or used an old version headlamp-plugin create.
   *
   * Assumes we are in the package folder.
   */
  function addMissingTemplateFiles() {
    const missingFiles = [
      path.join('src', 'headlamp-plugin.d.ts'),
      path.join('.vscode', 'extensions.json'),
      path.join('.vscode', 'settings.json'),
      path.join('.vscode', 'tasks.json'),
      'tsconfig.json',
    ];
    const templateFolder = path.resolve(__dirname, '..', 'template');

    missingFiles.forEach(pathToCheck => {
      const from = path.join(templateFolder, pathToCheck);
      const to = path.join('.', pathToCheck);

      // only copy it if it doesn't exist
      if (!fs.existsSync(to)) {
        console.log(`Adding missing file: "${to}"`);
        // Make the folder in to there if it is not.
        fs.mkdirSync(path.dirname(to), { recursive: true });
        fs.copyFileSync(from, to);
      }
      // Add file if it is different
      if (fs.readFileSync(from, 'utf8') !== fs.readFileSync(to, 'utf8')) {
        console.log(`Updating file: "${to}"`);
        fs.copyFileSync(from, to);
      }
    });
  }

  /**
   * If there are material-ui v4 files in src/ folder, upgrade them to v5.
   *
   * @see https://mui.com/material-ui/migration/migration-v4/#run-codemods
   */
  function upgradeMui() {
    const hasMaterialUI = fs
      .readdirSync('src', { withFileTypes: true })
      .filter(dirent => dirent.isFile() && dirent.name.endsWith('.ts'))
      .map(dirent => path.join('src', dirent.name))
      .filter(path => fs.readFileSync(path, 'utf8').includes('@material-ui'));

    if (hasMaterialUI.length > 0) {
      console.log('Found files with "@material-ui". Upgrading material-ui v4 to mui v5...');
      const cmd = 'npx @mui/codemod v5.0.0/preset-safe src';
      if (runCmd(cmd, '.')) {
        console.error(`Failed to upgrade material-ui v4 to mui v5.`);
        return false;
      }
    }
    return true;
  }

  /**
   * Some files should not be there anymore.
   *
   * Assumes we are in the package folder.
   */
  function removeFiles() {
    const filesToRemove = ['jsconfig.json'];

    filesToRemove.forEach(pathToCheck => {
      const removePath = path.join('.', pathToCheck);
      if (fs.existsSync(removePath)) {
        console.log(`Removing file: "${removePath}"`);
        fs.unlinkSync(removePath);
      }
    });
  }

  /**
   * Adds missing config into package.json
   */
  function addMissingConfiguration() {
    const templateFolder = path.resolve(__dirname, '..', 'template');
    const packageJsonPath = path.join('.', 'package.json');
    const templatePackageJson = JSON.parse(
      fs.readFileSync(path.join(templateFolder, 'package.json'), 'utf8')
    );
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    let configChanged = false;

    /**
     * replaceNestedKeys is used to replace nested keys in the package.json file.
     *
     * It only replaces the properties specified, and does so if they
     * are missing or not equal to the ones in the template.
     *
     * @param {string} keyName top-level key in the package.json file that contains the nested keys to be replaced.
     * @param {string[]} subProperties names of the nested keys to be replaced in keyName.
     */
    function replaceNestedKeys(keyName, subProperties) {
      subProperties.forEach(key => {
        if (packageJson[keyName][key] !== templatePackageJson[keyName][key]) {
          packageJson[keyName][key] = templatePackageJson[keyName][key];
          configChanged = true;
          console.log(
            `Updated package.json field ${keyName}.${key}: ${JSON.stringify(
              packageJson[keyName][key]
            )}`
          );
        }
      });
    }

    // Update these scripts keys to match the template.
    replaceNestedKeys('scripts', ['tsc', 'storybook', 'test', 'storybook-build']);

    // replace top level keys
    const checkKeys = ['eslintConfig', 'prettier', 'overrides'];
    checkKeys.forEach(key => {
      if (JSON.stringify(packageJson[key]) !== JSON.stringify(templatePackageJson[key])) {
        packageJson[key] = templatePackageJson[key];
        configChanged = true;
        console.log(`Updated package.json field "${key}": ${JSON.stringify(packageJson[key])}`);
      }
    });

    if (configChanged) {
      fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, '  ') + '\n');
    }
  }

  /**
   * Runs the command (more conveniently than node).
   *
   * @param {string} cmd - that you want to run.
   * @param {string} folder = folder to run inside.
   * @returns status code, so 0 on success and failure otherwise.
   */
  function runCmd(cmd, folder) {
    console.log(`Running cmd:"${cmd}" inside of ${folder} abs: "${resolve(folder)}"`);
    try {
      child_process.execSync(cmd, {
        stdio: 'inherit',
        encoding: 'utf8',
      });
    } catch (e) {
      console.error(`Problem running ${cmd}`);
      return e.status;
    }
    return 0;
  }

  /**
   * In order to more robustly upgrade packages,
   * we reset the package-lock.json and node_modules.
   *
   * @returns true unless there is a problem.
   */
  function resetPackageLock() {
    if (fs.existsSync('node_modules')) {
      console.log(`Resetting node_modules folder for more robust package upgrade...`);
      // Remove the node_modules folder
      fs.rmSync('node_modules', { recursive: true });

      if (fs.existsSync('node_modules')) {
        console.error(`Failed to remove node_modules folder.`);
        return false;
      }
    }
    if (fs.existsSync('package-lock.json')) {
      console.log(`Resetting package-lock.json file for more robust package upgrade...`);
      fs.unlinkSync('package-lock.json');
    }
    return true;
  }

  /**
   * Upgrades "@kinvolk/headlamp-plugin" dependency to latest or given version.
   *
   * @returns true unless there is a problem with the upgrade.
   */
  function upgradeHeadlampPlugin() {
    const theTag = headlampPluginVersion ? headlampPluginVersion : 'latest';
    if (
      headlampPluginVersion !== undefined ||
      '@kinvolk/headlamp-plugin' in getNpmOutdated() ||
      !fs.existsSync('node_modules')
    ) {
      // Upgrade the @kinvolk/headlamp-plugin

      const cmd = `npm install @kinvolk/headlamp-plugin@${theTag} --save`;
      if (runCmd(cmd, '.')) {
        return false;
      }
    }

    return true;
  }

  /**
   * Removes "@headlamp-k8s/eslint-config" dependency if it is there.
   *
   * It is a transitive dependency of "@kinvolk/headlamp-plugin", and
   * does not need to be there anymore.
   *
   * @returns true unless there is a problem with the upgrade.
   */
  function removeEslintConfig() {
    const packageJsonPath = path.join('.', 'package.json');
    let packageJson = {};
    try {
      packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    } catch (e) {
      console.error(`Error: Failed to read package.json from "${packageJsonPath}".`);
      return false;
    }
    const oldVersion = packageJson.devDependencies['@headlamp-k8s/eslint-config'];
    // remove @headlamp-k8s/eslint-config if it is there
    if (oldVersion) {
      const cmd = `npm remove @headlamp-k8s/eslint-config --save`;
      if (runCmd(cmd, '.')) {
        return false;
      }
    }

    return true;
  }

  /**
   * Upgrade a single package in a folder.
   *
   * @param {string} folder - where the package is.
   * @param {boolean | undefined} skipPackageUpdates - If true do not update packages.
   * @returns {boolean} - true if it is successful upgrading
   */
  function upgradePackage(folder, skipPackageUpdates) {
    const oldCwd = process.cwd();

    process.chdir(folder);
    console.log(`Upgrading "${folder}"...`);

    addMissingTemplateFiles();
    addMissingConfiguration();
    removeFiles();

    let failed = false;
    let reason = '';
    if (skipPackageUpdates !== true) {
      if (!failed && !removeEslintConfig()) {
        failed = true;
        reason = 'removing @headlamp-k8s/eslint-config failed.';
      }
      if (!failed && !resetPackageLock()) {
        failed = true;
        reason = 'resetting package-lock.json and node_modules failed.';
      }
      if (!failed && !upgradeHeadlampPlugin()) {
        failed = true;
        reason = 'upgrading @kinvolk/headlamp-plugin failed.';
      }
      if (!failed && !upgradeMui()) {
        failed = true;
        reason = 'upgrading from material-ui 4 to mui 5 failed.';
      }
      if (!failed && runCmd('npm audit fix', folder)) {
        console.warn('"npm audit fix" failed. You may need to inspect your dependencies manually.');
      }
      if (!failed && runCmd('npm run format', folder)) {
        failed = true;
        reason = '"npm run format" failed.';
      }
      if (!failed && runCmd('npm run lint', folder)) {
        failed = true;
        reason = '"npm run lint" failed.';
      }
      if (!failed && runCmd('npm run tsc', folder)) {
        failed = true;
        reason = '"npm run tsc" failed';
      }
    }
    if (failed) {
      console.error(`Failed upgrading: "${folder}". Reason: ${reason}`);
    } else {
      console.log(`Successfully upgraded: "${folder}".`);
    }
    process.chdir(oldCwd);
    return !failed;
  }

  /**
   * Upgrade each package inside the folder.
   *
   * @param {fs.Dirent[]} packageFolders - folders to upgrade.
   * @param {boolean | undefined} skipPackageUpdates - If true do not update packages.
   * @returns {boolean} - true if all of them are upgraded successfully.
   */
  function upgradeFolderOfPackages(packageFolders, skipPackageUpdates) {
    let failed = '';

    for (const folder of packageFolders) {
      if (failed) {
        console.error(
          `Skipping "${folder.name}", because "${failed}" did not upgrade successfully.`
        );
        continue;
      }
      const folderToUpgrade = path.join(packageFolder, folder.name);
      if (!upgradePackage(folderToUpgrade, skipPackageUpdates)) {
        failed = folderToUpgrade;
      }
    }
    return !failed;
  }

  if (!fs.existsSync(packageFolder)) {
    console.error(`"${packageFolder}" does not exist. Not upgrading.`);
    return 1;
  }

  if (fs.existsSync(path.join(packageFolder, 'package.json'))) {
    if (!upgradePackage(packageFolder, skipPackageUpdates)) {
      return 1;
    }
  } else {
    const packageFolders = fs
      .readdirSync(packageFolder, { withFileTypes: true })
      .filter(fileName => {
        return (
          fileName.isDirectory() &&
          fs.existsSync(path.join(packageFolder, fileName.name, 'package.json'))
        );
      });
    if (packageFolders.length === 0) {
      console.error(`"${packageFolder}" does not contain a package or packages. Not upgrading.`);
      return 1;
    }
    if (!upgradeFolderOfPackages(packageFolders, skipPackageUpdates)) {
      return 1;
    }
  }

  return 0;
}

/**
 * Lint code with eslint. Lint the plugin package or folder of packages.
 *
 * @param packageFolder {string} - folder where the package, or folder of packages is.
 * @param fix {boolean} - automatically fix problems.
 * @returns {0 | 1} - Exit code, where 0 is success, 1 is failure.
 */
function lint(packageFolder, fix) {
  const script = `eslint --cache -c package.json --max-warnings 0 --ext .js,.ts,.tsx src/${
    fix ? ' --fix' : ''
  }`;
  return runScriptOnPackages(packageFolder, 'lint', script, {});
}

/**
 * Type check code with tsc. Type check the plugin package or folder of packages.
 *
 * @param packageFolder {string} - folder where the package, or folder of packages is.
 * @returns {0 | 1} - Exit code, where 0 is success, 1 is failure.
 */
function tsc(packageFolder) {
  const script = 'tsc --noEmit';
  return runScriptOnPackages(packageFolder, 'tsc', script, {});
}

/**
 * Start storybook.
 *
 * @param packageFolder {string} - folder where the package is.
 * @returns {0 | 1} Exit code, where 0 is success, 1 is failure.
 */
function storybook(packageFolder) {
  try {
    child_process.execSync(
      './node_modules/.bin/storybook dev -p 6007 -c node_modules/@kinvolk/headlamp-plugin/config/.storybook',
      {
        stdio: 'inherit',
        cwd: packageFolder,
        encoding: 'utf8',
      }
    );
  } catch (e) {
    console.error(
      `Problem running storybook dev inside of "${packageFolder}" abs: "${resolve(packageFolder)}"`
    );
    return 1;
  }

  return 0;
}

/**
 * Build storybook.
 *
 * @param packageFolder {string} - folder where the package is.
 * @returns {0 | 1} Exit code, where 0 is success, 1 is failure.
 */
function storybook_build(packageFolder) {
  const script = `storybook build -c node_modules/@kinvolk/headlamp-plugin/config/.storybook`;
  return runScriptOnPackages(packageFolder, 'storybook build', script, {});
}

/**
 * Run tests.
 *
 * @param packageFolder {string} - folder where the package is.
 * @returns {0 | 1} Exit code, where 0 is success, 1 is failure.
 */
function test(packageFolder) {
  const script = `vitest -c node_modules/@kinvolk/headlamp-plugin/config/vite.config.mjs`;
  return runScriptOnPackages(packageFolder, 'test', script, { UNDER_TEST: 'true' });
}

// const headlampPluginBin = fs.realpathSync(process.argv[1]);
// console.log('headlampPluginBin path:', headlampPluginBin);

yargs(process.argv.slice(2))
  .command(
    'build [package]',
    'Build the plugin, or folder of plugins. <package> defaults to current working directory.',
    yargs => {
      yargs.positional('package', {
        describe: 'Package or folder of packages to build',
        type: 'string',
        default: '.',
      });
    },
    async argv => {
      // @ts-ignore
      process.exitCode = await build(argv.package);
    }
  )
  .command('start', 'Watch for changes and build plugin.', {}, async () => {
    process.exitCode = await start();
  })
  .command(
    'create <name>',
    'Create a new plugin folder.',
    yargs => {
      yargs
        .positional('name', {
          describe: 'Name of package',
          type: 'string',
        })
        .option('link', {
          describe:
            'For development of headlamp-plugin itself, so it uses npm link @kinvolk/headlamp-plugin.',
          type: 'boolean',
        });
    },
    argv => {
      // @ts-ignore
      process.exitCode = create(argv.name, argv.link);
    }
  )
  .command(
    'extract <pluginPackages> <outputPlugins>',
    'Copies folders of packages from pluginPackages/packageName/dist/main.js ' +
      'to outputPlugins/packageName/main.js.',
    yargs => {
      yargs.positional('pluginPackages', {
        describe:
          'A folder of plugin packages that have been built with dist/main.js in them.' +
          'Can also be a single package folder.',
        type: 'string',
      });
      yargs.positional('outputPlugins', {
        describe:
          'A plugins folder (eg. ".plugins") to extract plugins to. ' +
          'The output is a series of packageName/main.js. ' +
          'Creates this folder if it does not exist.',
        type: 'string',
      });
    },
    argv => {
      // @ts-ignore
      process.exitCode = extract(argv.pluginPackages, argv.outputPlugins);
    }
  )
  .command(
    'package [pluginPath] [outputDir]',
    'Creates a tarball of the plugin package in the format Headlamp expects.',
    yargs => {
      yargs.positional('pluginPath', {
        describe:
          'A folder of a plugin package that have been built with dist/main.js in it.' +
          ' Defaults to current working directory.',
        type: 'string',
      });
      yargs.positional('outputDir', {
        describe:
          'The destination folder in which to create the archive.' +
          'Creates this folder if it does not exist.',
        type: 'string',
      });
    },
    async argv => {
      let pluginPath = argv.pluginPath;
      if (!pluginPath) {
        pluginPath = process.cwd();
      }

      let outputDir = argv.outputDir;
      if (!outputDir) {
        outputDir = process.cwd();
      }

      process.exitCode = await createArchive(pluginPath, outputDir);
    }
  )
  .command(
    'format [package]',
    'format the plugin code with prettier. <package> defaults to current working directory.' +
      ' Can also be a folder of packages.',
    yargs => {
      yargs
        .positional('package', {
          describe: 'Package to code format',
          type: 'string',
          default: '.',
        })
        .option('check', {
          describe: 'Check the formatting without changing files',
          type: 'boolean',
        });
    },
    argv => {
      // @ts-ignore
      process.exitCode = format(argv.package, argv.check);
    }
  )
  .command(
    'lint [package]',
    'Lint the plugin for coding issues with eslint. ' +
      '<package> defaults to current working directory.' +
      ' Can also be a folder of packages.',
    yargs => {
      yargs
        .positional('package', {
          describe: 'Package to lint',
          type: 'string',
          default: '.',
        })
        .option('fix', {
          describe: 'Automatically fix problems',
          type: 'boolean',
        });
    },
    argv => {
      // @ts-ignore
      process.exitCode = lint(argv.package, argv.fix);
    }
  )
  .command(
    'tsc [package]',
    'Type check the plugin for coding issues with tsc. ' +
      '<package> defaults to current working directory.' +
      ' Can also be a folder of packages.',
    yargs => {
      yargs.positional('package', {
        describe: 'Package to type check',
        type: 'string',
        default: '.',
      });
    },
    argv => {
      // @ts-ignore
      process.exitCode = tsc(argv.package);
    }
  )
  .command(
    'storybook [package]',
    'Start storybook. <package> defaults to current working directory.',
    yargs => {
      yargs.positional('package', {
        describe: 'Package to start storybook for',
        type: 'string',
        default: '.',
      });
    },
    argv => {
      // @ts-ignore
      process.exitCode = storybook(argv.package);
    }
  )
  .command(
    'storybook-build [package]',
    'Build static storybook. <package> defaults to current working directory.' +
      ' Can also be a folder of packages.',
    yargs => {
      yargs.positional('package', {
        describe: 'Package to build storybook for',
        type: 'string',
        default: '.',
      });
    },
    argv => {
      // @ts-ignore
      process.exitCode = storybook_build(argv.package);
    }
  )
  .command(
    'upgrade [package]',
    'Upgrade the plugin to latest headlamp-plugin; ' +
      'upgrades headlamp-plugin and audits packages, formats, lints, type checks.' +
      '<package> defaults to current working directory. Can also be a folder of packages.',
    yargs => {
      yargs
        .positional('package', {
          describe: 'Package to upgrade',
          type: 'string',
          default: '.',
        })
        .option('skip-package-updates', {
          describe: 'For development of headlamp-plugin itself, so it does not do package updates.',
          type: 'boolean',
        })
        .option('headlamp-plugin-version', {
          describe:
            'Use a specific headlamp-plugin-version when upgrading packages. Defaults to "latest".',
          type: 'string',
        });
    },
    argv => {
      // @ts-ignore
      process.exitCode = upgrade(argv.package, argv.skipPackageUpdates, argv.headlampPluginVersion);
    }
  )
  .command(
    'test [package]',
    'Test. <package> defaults to current working directory.' + ' Can also be a folder of packages.',
    yargs => {
      yargs.positional('package', {
        describe: 'Package to test',
        type: 'string',
        default: '.',
      });
    },
    argv => {
      // @ts-ignore
      process.exitCode = test(argv.package);
    }
  )
  .command(
    'install <URL>',
    'Install a plugin from the Artiface Hub URL',
    yargs => {
      yargs
        .positional('URL', {
          describe: 'URL of the plugin to install',
          type: 'string',
        })
        .option('folderName', {
          describe: 'Name of the folder to install the plugin into',
          type: 'string',
        })
        .option('headlampVersion', {
          describe: 'Version of headlamp to install the plugin into',
          type: 'string',
        })
        .option('quiet', {
          alias: 'q',
          describe: 'Do not print logs',
          type: 'boolean',
        });
    },
    async argv => {
      const { URL, folderName, headlampVersion, quiet } = argv;
      const progressCallback = quiet
        ? null
        : data => {
            if (data.type === 'error' || data.type === 'success') {
              console.error(data.type, ':', data.message);
            }
          }; // Use console.log for logs if not in quiet mode
      try {
        await PluginManager.install(URL, folderName, headlampVersion, progressCallback);
      } catch (e) {
        console.error(e.message);
        process.exit(1); // Exit with error status
      }
    }
  )
  .command(
    'update <pluginName>',
    'Update a plugin to the latest version',
    yargs => {
      yargs
        .positional('pluginName', {
          describe: 'Name of the plugin to update',
          type: 'string',
        })
        .positional('folderName', {
          describe: 'Name of the folder that contains the plugin',
          type: 'string',
        })
        .positional('headlampVersion', {
          describe: 'Version of headlamp to update the plugin into',
          type: 'string',
        })
        .option('quiet', {
          alias: 'q',
          describe: 'Do not print logs',
          type: 'boolean',
        });
    },
    async argv => {
      const { pluginName, folderName, headlampVersion, quiet } = argv;
      const progressCallback = quiet
        ? null
        : data => {
            if (data.type === 'error' || data.type === 'success') {
              console.error(data.type, ':', data.message);
            }
          }; // Use console.log for logs if not in quiet mode
      try {
        await PluginManager.update(pluginName, folderName, headlampVersion, progressCallback);
      } catch (e) {
        console.error(e.message);
        process.exit(1); // Exit with error status
      }
    }
  )
  .command(
    'uninstall <pluginName>',
    'Uninstall a plugin',
    yargs => {
      yargs
        .positional('pluginName', {
          describe: 'Name of the plugin to uninstall',
          type: 'string',
        })
        .option('folderName', {
          describe: 'Name of the folder that contains the plugin',
          type: 'string',
        })
        .option('quiet', {
          alias: 'q',
          describe: 'Do not print logs',
          type: 'boolean',
        });
    },
    async argv => {
      const { pluginName, folderName, quiet } = argv;
      const progressCallback = quiet
        ? null
        : data => {
            if (data.type === 'error' || data.type === 'success') {
              console.error(data.type, ':', data.message);
            }
          }; // Use console.log for logs if not in quiet mode
      try {
        await PluginManager.uninstall(pluginName, folderName, progressCallback);
      } catch (e) {
        console.error(e.message);
        process.exit(1); // Exit with error status
      }
    }
  )
  .command(
    'list',
    'List installed plugins',
    yargs => {
      yargs
        .option('folderName', {
          describe: 'Name of the folder that contains the plugins',
          type: 'string',
        })
        .option('json', {
          alias: 'j',
          describe: 'Output in JSON format',
          type: 'boolean',
        });
    },
    async argv => {
      const { folderName, json } = argv;
      const progressCallback = data => {
        if (json) {
          console.log(JSON.stringify(data.data));
        } else {
          // display table
          const rows = [['Name', 'Version', 'Folder Name', 'Repo', 'Author']];
          data.data.forEach(plugin => {
            rows.push([
              plugin.pluginName,
              plugin.pluginVersion,
              plugin.folderName,
              plugin.repoName,
              plugin.author,
            ]);
          });
          console.log(table(rows));
        }
      };
      try {
        await PluginManager.list(folderName, progressCallback);
      } catch (e) {
        console.error(e.message);
        process.exit(1); // Exit with error status
      }
    }
  )
  .demandCommand(1, '')
  .strict()
  .help().argv;



---
File: /plugins/headlamp-plugin/config/.storybook/HeadlampTheme.js
---

// https://storybook.js.org/docs/react/configure/theming#create-a-theme-quickstart
//  To workaround a bug at time of writing, where theme is not refreshed,
//  you may need to `npm run storybook --no-manager-cache`
import { create } from '@storybook/theming';

export default create({
  base: 'light',
  brandTitle: 'Headlamp plugin storybook',
  brandUrl: 'https://headlamp.dev/docs/latest/development/plugins/functionality/#functionality',
});



---
File: /plugins/headlamp-plugin/config/.storybook/main.js
---

module.exports = {
  stories: [
    '../../../../../src/**/*.stories.mdx',
    '../../../../../src/**/*.stories.@(js|jsx|ts|tsx)',
  ],
  addons: ['@storybook/addon-links', '@storybook/addon-essentials'],
  core: {
    builder: '@storybook/builder-vite',
    disableTelemetry: true,
  },
  framework: {
    name: '@storybook/react-vite',
    options: {},
  },
  // https://storybook.js.org/docs/react/configure/typescript#mainjs-configuration
  typescript: {
    check: false,
    reactDocgen: true,
    reactDocgenTypescriptOptions: {
      shouldExtractLiteralValuesFromEnum: true,
      propFilter: prop => (prop.parent ? !/node_modules/.test(prop.parent.fileName) : true),
    },
  },
};



---
File: /plugins/headlamp-plugin/config/.storybook/manager.js
---

import { addons } from '@storybook/manager-api';
import theme from './HeadlampTheme';

addons.setConfig({
  theme: theme,
});



---
File: /plugins/headlamp-plugin/config/storyshots/storyshots-test.ts
---

import { test } from 'vitest';

export function initTests() {
  console.warn(
    'Storyshots are deprecated. See more at: https://storybook.js.org/docs/writing-tests/storyshots-migration-guide/'
  );

  test.skip('Storyshots are deprecated', () => {});
}



---
File: /plugins/headlamp-plugin/config/setupTests.js
---

import { vi } from 'vitest';

Object.assign(globalThis, { jest: vi });



---
File: /plugins/headlamp-plugin/plugin-management/plugin-management.e2e.js
---

#!/bin/env node
const { execSync } = require('child_process');
const assert = require('assert');
const fs = require('fs');
const path = require('path');
const envPaths = require('env-paths');

// Helper function to run CLI commands and return the output
function runCommand(command) {
  try {
    return execSync(command, { encoding: 'utf8' });
  } catch (error) {
    console.error(`Error running command "${command}":`, error);
    process.exit(1);
  }
}

// Helper function to get the default plugins directory
function defaultPluginsDir() {
  const paths = envPaths('Headlamp', { suffix: '' });
  const configDir = fs.existsSync(paths.data) ? paths.data : paths.config;
  return path.join(configDir, 'plugins');
}

// create default plugins directory if it doesn't exist
const pluginsDir = defaultPluginsDir();
if (!fs.existsSync(pluginsDir)) {
  fs.mkdirSync(pluginsDir, { recursive: true });
}

// List plugins initially
let output = runCommand('node ../bin/headlamp-plugin.js list --json');
console.log('Initial list output:', output);
let plugins = JSON.parse(output);
console.log('Initial plugins:', plugins);

// Ensure the plugin is not installed
const pluginName = 'prometheus';
let pluginExists = plugins.some(plugin => plugin.pluginName === pluginName);
assert.strictEqual(pluginExists, false, 'Plugin should not be initially installed');

// Install the plugin
const pluginURL = 'https://artifacthub.io/packages/headlamp/test-123/prometheus_headlamp_plugin';
output = runCommand(`node ../bin/headlamp-plugin.js install ${pluginURL}`);
console.log('Install output:', output);

// List plugins to verify installation
output = runCommand('node ../bin/headlamp-plugin.js list --json');
plugins = JSON.parse(output);
console.log('Plugins after install:', plugins);
pluginExists = plugins.some(plugin => plugin.pluginName === pluginName);
assert.strictEqual(pluginExists, true, 'Plugin should be installed');

// Update the plugin
output = runCommand(`node ../bin/headlamp-plugin.js update ${pluginName}`);
console.log('Update output:', output);

// List plugins to verify update
output = runCommand('node ../bin/headlamp-plugin.js list --json');
plugins = JSON.parse(output);
console.log('Plugins after update:', plugins);
pluginExists = plugins.some(plugin => plugin.pluginName === pluginName);
assert.strictEqual(pluginExists, true, 'Plugin should still be installed after update');

// Uninstall the plugin
output = runCommand(`node ../bin/headlamp-plugin.js uninstall ${pluginName}`);
console.log('Uninstall output:', output);

// List plugins to verify uninstallation
output = runCommand('node ../bin/headlamp-plugin.js list --json');
console.log('Initial list output:', output);
plugins = JSON.parse(output);
console.log('Plugins after uninstall:', plugins);
pluginExists = plugins.some(plugin => plugin.pluginName === pluginName);
assert.strictEqual(pluginExists, false, 'Plugin should be uninstalled');

console.log('All tests passed successfully.');



---
File: /plugins/headlamp-plugin/plugin-management/plugin-management.js
---

/**
 * plugin-management-utils.js has the core logic for managing plugins in Headlamp.
 *
 * Provides methods for installing, updating, listing and uninstalling plugins.
 *
 * Used by:
 * - plugins/headlamp-plugin/bin/headlamp-plugin.js cli
 * - app/ to manage plugins.
 */
const fs = require('fs');
const os = require('os');
const zlib = require('zlib');
const tar = require('tar');
const path = require('path');
const crypto = require('crypto');
const stream = require('stream');
const semver = require('semver');
const envPaths = require('env-paths');

// comment out for testing
// function sleep(ms) {
//   // console.log(ms)
//   // return new Promise(function (resolve) {
//   //   setTimeout(resolve, ms+2000);
//   // });
// }

/**
 * Move directories from currentPath to newPath by copying.
 * @param currentPath from this path
 * @param newPath to this path
 */
function moveDirs(currentPath, newPath) {
  try {
    fs.cpSync(currentPath, newPath, { recursive: true, force: true });
    fs.rmSync(currentPath, { recursive: true });
    console.log(`Moved directory from ${currentPath} to ${newPath}`);
  } catch (err) {
    console.error(`Error moving directory from ${currentPath} to ${newPath}:`, err);
    throw err;
  }
}

class PluginManager {
  /**
   * Installs a plugin from the specified URL.
   * @param {string} URL - The URL of the plugin to install.
   * @param {string} [destinationFolder=defaultPluginsDir()] - The folder where the plugin will be installed.
   * @param {string} [headlampVersion=""] - The version of Headlamp for compatibility checking.
   * @param {function} [progressCallback=null] - Optional callback for progress updates.
   * @param {AbortSignal} [signal=null] - Optional AbortSignal for cancellation.
   * @returns {Promise<void>} A promise that resolves when the installation is complete.
   */
  static async install(
    URL,
    destinationFolder = defaultPluginsDir(),
    headlampVersion = '',
    progressCallback = null,
    signal = null
  ) {
    try {
      const [name, tempFolder] = await downloadExtractPlugin(
        URL,
        headlampVersion,
        progressCallback,
        signal
      );

      // sleep(2000);  // comment out for testing

      // create the destination folder if it doesn't exist
      if (!fs.existsSync(destinationFolder)) {
        fs.mkdirSync(destinationFolder, { recursive: true });
      }
      // move the plugin to the destination folder
      moveDirs(tempFolder, path.join(destinationFolder, path.basename(name)));
      if (progressCallback) {
        progressCallback({ type: 'success', message: 'Plugin Installed' });
      }
    } catch (e) {
      if (progressCallback) {
        progressCallback({ type: 'error', message: e.message });
      } else {
        throw e;
      }
    }
  }

  /**
   * Updates an installed plugin to the latest version.
   * @param {string} pluginName - The name of the plugin to update.
   * @param {string} [destinationFolder=defaultPluginsDir()] - The folder where the plugin is installed.
   * @param {string} [headlampVersion=""] - The version of Headlamp for compatibility checking.
   * @param {function} [progressCallback=null] - Optional callback for progress updates.
   * @param {AbortSignal} [signal=null] - Optional AbortSignal for cancellation.
   * @returns {Promise<void>} A promise that resolves when the update is complete.
   */
  static async update(
    pluginName,
    destinationFolder = defaultPluginsDir(),
    headlampVersion = '',
    progressCallback = null,
    signal = null
  ) {
    try {
      const installedPlugins = PluginManager.list(destinationFolder);
      const plugin = installedPlugins.find(p => p.pluginName === pluginName);
      if (!plugin) {
        throw new Error('Plugin not found');
      }

      const pluginDir = path.join(destinationFolder, plugin.folderName);
      // read the package.json of the plugin
      const packageJsonPath = path.join(pluginDir, 'package.json');
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

      const pluginData = await fetchPluginInfo(plugin.artifacthubURL, progressCallback, signal);

      const latestVersion = pluginData.version;
      const currentVersion = packageJson.artifacthub.version;

      if (semver.lte(latestVersion, currentVersion)) {
        throw new Error('No updates available');
      }

      // eslint-disable-next-line no-unused-vars
      const [_, tempFolder] = await downloadExtractPlugin(
        plugin.artifacthubURL,
        headlampVersion,
        progressCallback,
        signal
      );

      // sleep(2000);  // comment out for testing

      // create the destination folder if it doesn't exist
      if (!fs.existsSync(destinationFolder)) {
        fs.mkdirSync(destinationFolder, { recursive: true });
      }

      // remove the existing plugin folder
      fs.rmdirSync(pluginDir, { recursive: true });

      // create the plugin folder
      fs.mkdirSync(pluginDir, { recursive: true });

      // move the plugin to the destination folder
      moveDirs(tempFolder, pluginDir);
      if (progressCallback) {
        progressCallback({ type: 'success', message: 'Plugin Updated' });
      }
    } catch (e) {
      if (progressCallback) {
        progressCallback({ type: 'error', message: e.message });
      } else {
        throw e;
      }
    }
  }

  /**
   * Uninstalls a plugin from the specified folder.
   * @param {string} name - The name of the plugin to uninstall.
   * @param {string} [folder=defaultPluginsDir()] - The folder where the plugin is installed.
   * @param {function} [progressCallback=null] - Optional callback for progress updates.
   * @returns {void}
   */
  static uninstall(name, folder = defaultPluginsDir(), progressCallback = null) {
    try {
      const installedPlugins = PluginManager.list(folder);
      const plugin = installedPlugins.find(p => p.pluginName === name);
      if (!plugin) {
        throw new Error('Plugin not found');
      }

      const pluginDir = path.join(folder, plugin.folderName);
      if (!checkValidPluginFolder(pluginDir)) {
        throw new Error('Invalid plugin folder');
      }

      if (fs.existsSync(pluginDir)) {
        fs.rmdirSync(pluginDir, { recursive: true });
      } else {
        throw new Error('Plugin not found');
      }
      if (progressCallback) {
        progressCallback({ type: 'success', message: 'Plugin Uninstalled' });
      }
    } catch (e) {
      if (progressCallback) {
        progressCallback({ type: 'error', message: e.message });
      } else {
        throw e;
      }
    }
  }

  /**
   * Lists all valid plugins in the specified folder.
   * @param {string} [folder=defaultPluginsDir()] - The folder to list plugins from.
   * @param {function} [progressCallback=null] - Optional callback for progress updates.
   * @returns {Array<object>} An array of objects representing valid plugins.
   */
  static list(folder = defaultPluginsDir(), progressCallback = null) {
    try {
      const pluginsData = [];

      // Read all entries in the specified folder
      const entries = fs.readdirSync(folder, { withFileTypes: true });

      // Filter out directories (plugins)
      const pluginFolders = entries.filter(entry => entry.isDirectory());

      // Iterate through each plugin folder
      for (const pluginFolder of pluginFolders) {
        const pluginDir = path.join(folder, pluginFolder.name);

        if (checkValidPluginFolder(pluginDir)) {
          // Read package.json to get the plugin name and version
          const packageJsonPath = path.join(pluginDir, 'package.json');
          const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
          const pluginName = packageJson.name || pluginFolder.name;
          const pluginTitle = packageJson.artifacthub.title;
          const pluginVersion = packageJson.version || null;
          const artifacthubURL = packageJson.artifacthub ? packageJson.artifacthub.url : null;
          const repoName = packageJson.artifacthub ? packageJson.artifacthub.repoName : null;
          const author = packageJson.artifacthub ? packageJson.artifacthub.author : null;
          const artifacthubVersion = packageJson.artifacthub
            ? packageJson.artifacthub.version
            : null;
          // Store plugin data (folder name and plugin name)
          pluginsData.push({
            pluginName,
            pluginTitle,
            pluginVersion,
            folderName: pluginFolder.name,
            artifacthubURL: artifacthubURL,
            repoName: repoName,
            author: author,
            artifacthubVersion: artifacthubVersion,
          });
        }
      }

      if (progressCallback) {
        progressCallback({ type: 'success', message: 'Plugins Listed', data: pluginsData });
      } else {
        return pluginsData;
      }
    } catch (e) {
      if (progressCallback) {
        progressCallback({ type: 'error', message: e.message });
      } else {
        throw e;
      }
    }
  }
}

/**
 * Checks the plugin name is a valid one.
 *
 * Look for "..", "/", or "\" in the plugin name.
 *
 * @param {string} pluginName
 *
 * @returns true if the name is valid.
 */
function validatePluginName(pluginName) {
  const invalidPattern = /[\/\\]|(\.\.)/;
  return !invalidPattern.test(pluginName);
}

/**
 * @param {string} archiveURL - the one to validate
 * @returns true if the archiveURL looks good.
 */
function validateArchiveURL(archiveURL) {
  const githubRegex = /^https:\/\/github\.com\/[^/]+\/[^/]+\/(releases|archive)\/.*$/;
  const bitbucketRegex = /^https:\/\/bitbucket\.org\/[^/]+\/[^/]+\/(downloads|get)\/.*$/;
  const gitlabRegex = /^https:\/\/gitlab\.com\/[^/]+\/[^/]+\/(-\/archive|releases)\/.*$/;

  // @todo There is a test plugin at https://github.com/yolossn/headlamp-plugins/
  // need to move that somewhere else, or test differently.

  return (
    githubRegex.test(archiveURL) ||
    bitbucketRegex.test(archiveURL) ||
    gitlabRegex.test(archiveURL) ||
    archiveURL.startsWith('https://github.com/yolossn/headlamp-plugins/')
  );
}

/**
 * Downloads and extracts a plugin from the specified URL.
 * @param {string} URL - The URL of the plugin to download and extract.
 * @param {string} headlampVersion - The version of Headlamp for compatibility checking.
 * @param {function} progressCallback - A callback function for reporting progress.
 * @param {AbortSignal} signal - An optional AbortSignal for cancellation.
 * @returns {Promise<[string, string]>} A promise that resolves to an array containing the plugin name and temporary folder path.
 */
async function downloadExtractPlugin(URL, headlampVersion, progressCallback, signal) {
  // fetch plugin metadata
  if (signal && signal.aborted) {
    throw new Error('Download cancelled');
  }
  const pluginInfo = await fetchPluginInfo(URL, progressCallback, signal);
  // await sleep(4000);  // comment out for testing

  if (signal && signal.aborted) {
    throw new Error('Download cancelled');
  }
  if (progressCallback) {
    progressCallback({ type: 'info', message: 'Plugin Metadata Fetched' });
  }
  const pluginName = pluginInfo.name;
  if (!validatePluginName(pluginName)) {
    throw new Error('Invalid plugin name');
  }

  const archiveURL = pluginInfo.data['headlamp/plugin/archive-url'];
  if (!validateArchiveURL(archiveURL)) {
    throw new Error('Invalid plugin/archive-url');
  }

  let checksum = pluginInfo.data['headlamp/plugin/archive-checksum'];
  if (!archiveURL || !checksum) {
    throw new Error('Invalid plugin metadata. Please check the plugin details.');
  }
  if (checksum.startsWith('sha256:') || checksum.startsWith('SHA256:')) {
    checksum = checksum.replace('sha256:', '');
    checksum = checksum.replace('SHA256:', '');
  }

  // check if the plugin is compatible with the current Headlamp version
  if (headlampVersion) {
    if (progressCallback) {
      progressCallback({ type: 'info', message: 'Checking compatibility with Headlamp version' });
    }
    if (semver.satisfies(headlampVersion, pluginInfo.data['headlamp/plugin/version-compat'])) {
      if (progressCallback) {
        progressCallback({ type: 'info', message: 'Headlamp version is compatible' });
      }
    } else {
      throw new Error('Headlamp version is not compatible with the plugin');
    }
  }

  if (signal && signal.aborted) {
    throw new Error('Download cancelled');
  }

  const tempDir = await fs.mkdtempSync(path.join(os.tmpdir(), 'headlamp-plugin-temp-'));
  const tempFolder = fs.mkdirSync(path.join(tempDir, pluginName), { recursive: true });

  if (progressCallback) {
    progressCallback({ type: 'info', message: 'Downloading Plugin' });
  }
  if (signal && signal.aborted) {
    throw new Error('Download cancelled');
  }

  // await sleep(4000); // comment out for testing
  const archResponse = await fetch(archiveURL, { redirect: 'follow', follow: 10 }, { signal });
  if (!archResponse.ok) {
    throw new Error(`Failed to download tarball. Status code: ${archResponse.status}`);
  }

  if (signal && signal.aborted) {
    throw new Error('Download cancelled');
  }

  if (progressCallback) {
    progressCallback({ type: 'info', message: 'Plugin Downloaded' });
  }

  const archChunks = [];
  let archBufferLengeth = 0;

  for await (const chunk of archResponse.body) {
    archChunks.push(chunk);
    archBufferLengeth += chunk.length;
  }

  const archBuffer = Buffer.concat(archChunks, archBufferLengeth);

  const archiveChecksum = crypto.createHash('sha256').update(archBuffer).digest('hex');

  if (archiveChecksum !== checksum) {
    throw new Error('Checksum mismatch.');
  }

  if (signal && signal.aborted) {
    throw new Error('Download cancelled');
  }

  if (progressCallback) {
    progressCallback({ type: 'info', message: 'Extracting Plugin' });
  }
  const archStream = new stream.PassThrough();
  archStream.end(archBuffer);

  const extractStream = archStream.pipe(zlib.createGunzip()).pipe(
    tar.extract({
      cwd: tempFolder,
      strip: 1,
      sync: true,
    })
  );

  await new Promise((resolve, reject) => {
    extractStream.on('finish', () => {
      resolve();
    });
    extractStream.on('error', err => {
      reject(err);
    });
  });

  if (signal && signal.aborted) {
    throw new Error('Download cancelled');
  }

  if (progressCallback) {
    progressCallback({ type: 'info', message: 'Plugin Extracted' });
  }
  // add artifacthub metadata to the plugin
  const packageJSON = JSON.parse(fs.readFileSync(`${tempFolder}/package.json`, 'utf8'));
  packageJSON.artifacthub = {
    name: pluginName,
    title: pluginInfo.display_name,
    url: `https://artifacthub.io/packages/headlamp/${pluginInfo.repository.name}/${pluginName}`,
    version: pluginInfo.version,
    repoName: pluginInfo.repository.name,
    author: pluginInfo.repository.user_alias,
  };
  packageJSON.isManagedByHeadlampPlugin = true;
  fs.writeFileSync(`${tempFolder}/package.json`, JSON.stringify(packageJSON, null, 2));
  return [pluginName, tempFolder];
}

/**
 * Fetches plugin metadata from the specified URL.
 * @param {string} URL - The URL to fetch plugin metadata from.
 * @param {function} progressCallback - A callback function for reporting progress.
 * @param {AbortSignal} signal - An optional AbortSignal for cancellation.
 * @returns {Promise<object>} A promise that resolves to the fetched plugin metadata.
 */
async function fetchPluginInfo(URL, progressCallback, signal) {
  try {
    if (!URL.startsWith('https://artifacthub.io/packages/headlamp/')) {
      throw new Error('Invalid URL. Please provide a valid URL from ArtifactHub.');
    }

    const apiURL = URL.replace(
      'https://artifacthub.io/packages/headlamp/',
      'https://artifacthub.io/api/v1/packages/headlamp/'
    );

    if (progressCallback) {
      progressCallback({ type: 'info', message: 'Fetching Plugin Metadata' });
    }
    const response = await fetch(apiURL, { redirect: 'follow', follow: 10 }, { signal });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (e) {
    if (progressCallback) {
      progressCallback({ type: 'error', message: e.message });
    } else {
      throw e;
    }
  }
}

/**
 * Checks if a given folder is a valid Headlamp plugin folder.
 * A valid plugin folder must exist, contain 'main.js' and 'package.json' files,
 * and the 'package.json' file must have 'isManagedByHeadlampPlugin' set to true.
 *
 * @param {string} folder - The path to the folder to check.
 * @returns {boolean} True if the folder is a valid Headlamp plugin folder, false otherwise.
 */
function checkValidPluginFolder(folder) {
  if (!fs.existsSync(folder)) {
    return false;
  }
  // Check if the folder contains main.js and package.json
  const mainJsPath = path.join(folder, 'main.js');
  const packageJsonPath = path.join(folder, 'package.json');
  if (!fs.existsSync(mainJsPath) || !fs.existsSync(packageJsonPath)) {
    return false;
  }

  // Read package.json and check isManagedByHeadlampPlugin is set to true
  const packageJSON = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
  if (packageJSON.isManagedByHeadlampPlugin) {
    return true;
  }
  return false;
}

/**
 * Returns the default directory where Headlamp plugins are installed.
 * If the data path exists, it is used as the base directory.
 * Otherwise, the config path is used as the base directory.
 * The 'plugins' subdirectory of the base directory is returned.
 *
 * @returns {string} The path to the default plugins directory.
 */
function defaultPluginsDir() {
  const paths = envPaths('Headlamp', { suffix: '' });
  const configDir = fs.existsSync(paths.data) ? paths.data : paths.config;
  return path.join(configDir, 'plugins');
}

module.exports = { PluginManager, validateArchiveURL };



---
File: /plugins/headlamp-plugin/plugin-management/plugin-management.test.js
---

const pluginManagement = require('./plugin-management.js');
const tmp = require('tmp');
const fs = require('fs');
const semver = require('semver');

const PluginManager = pluginManagement.PluginManager;
const validateArchiveURL = pluginManagement.validateArchiveURL;


// Mocking progressCallback function for testing
// eslint-disable-next-line
const mockProgressCallback = jest.fn(args => {
  // console.log("Progress Callback:", args);  // Uncomment for debugging
});

describe('PluginManager Test Cases', () => {
  let tempDir;

  beforeAll(() => {
    // Create a temporary directory before all tests
    tempDir = tmp.dirSync({ unsafeCleanup: true }).name;
  });

  afterAll(() => {
    // Remove the temporary directory after all tests
    fs.rmdirSync(tempDir, { recursive: true });
  });

  beforeEach(() => {
    // Initialize a new PluginManager instance before each test
    jest.clearAllMocks();
  });

  test('Install Plugin', async () => {
    await PluginManager.install(
      'https://artifacthub.io/packages/headlamp/test-123/appcatalog_headlamp_plugin',
      tempDir,
      '',
      mockProgressCallback
    );
    expect(mockProgressCallback).toHaveBeenCalledWith({
      type: 'success',
      message: 'Plugin Installed',
    });
  });

  test('List Plugins', () => {
    PluginManager.list(tempDir, mockProgressCallback);
    // Assuming "app-catalog" plugin is in the list of plugins
    expect(mockProgressCallback).toHaveBeenCalledWith({
      type: 'success',
      message: 'Plugins Listed',
      data: expect.any(Array),
    });
  });

  test('No Update available for Plugin', async () => {
    // No updates available for "app-catalog" plugin
    await PluginManager.update('app-catalog', tempDir, '', mockProgressCallback);
    expect(mockProgressCallback).toHaveBeenCalledWith({
      type: 'error',
      message: 'No updates available',
    });
  });

  test('Update Plugin', async () => {
    // update the "app-catalog" plugin package.json with lower state
    const packageJSONPath = `${tempDir}/appcatalog_headlamp_plugin/package.json`;
    const packageJSON = JSON.parse(fs.readFileSync(packageJSONPath));
    packageJSON.artifacthub.version = `${semver.major(
      packageJSON.artifacthub.version
    )}.${semver.minor(packageJSON.artifacthub.version)}.${
      semver.patch(packageJSON.artifacthub.version) - 1
    }`; // Reduce the version using semver
    // Write the updated package.json back to the file
    fs.writeFileSync(packageJSONPath, JSON.stringify(packageJSON, null, 2));

    await PluginManager.update('app-catalog', tempDir, '', mockProgressCallback);
    expect(mockProgressCallback).toHaveBeenCalledWith({
      type: 'success',
      message: 'Plugin Updated',
    });
  });

  test('Uninstall Plugin', async () => {
    const tempDir = tmp.dirSync({ unsafeCleanup: true }).name;

    await PluginManager.install(
      'https://artifacthub.io/packages/headlamp/test-123/appcatalog_headlamp_plugin',
      tempDir,
      '',
      mockProgressCallback
    );
    expect(mockProgressCallback).toHaveBeenCalledWith({
      type: 'success',
      message: 'Plugin Installed',
    });

    PluginManager.uninstall('app-catalog', tempDir, mockProgressCallback);
    expect(mockProgressCallback).toHaveBeenCalledWith({
      type: 'success',
      message: 'Plugin Uninstalled',
    });

    fs.rmdirSync(tempDir, { recursive: true });
  });
});

describe('validateArchiveURL', () => {
  test('valid GitHub release URL', () => {
    expect(validateArchiveURL('https://github.com/kubernetes-sigs/headlamp/releases/download/v0.24.1/Headlamp-0.24.1-win-x64.exe')).toBe(true);
  });

  test('valid GitHub archive URL', () => {
    expect(validateArchiveURL('https://github.com/owner/repo/archive/refs/tags/v1.0.0.zip')).toBe(true);
  });

  test('valid Bitbucket download URL', () => {
    expect(validateArchiveURL('https://bitbucket.org/owner/repo/downloads/package-1.0.0.zip')).toBe(true);
  });

  test('valid Bitbucket get archive URL', () => {
    expect(validateArchiveURL('https://bitbucket.org/owner/repo/get/v1.0.0.tar.gz')).toBe(true);
  });

  test('valid GitLab release URL', () => {
    expect(validateArchiveURL('https://gitlab.com/gitlab-org/gitlab/-/archive/v17.2.0-ee/gitlab-v17.2.0-ee.tar.gz')).toBe(true);
  });

  test('invalid URL', () => {
    expect(validateArchiveURL('https://example.com/some/invalid/url')).toBe(false);
  });

  test('invalid GitHub URL', () => {
    expect(validateArchiveURL('https://github.com/owner/repo/invalid/path')).toBe(false);
  });

  test('invalid Bitbucket URL', () => {
    expect(validateArchiveURL('https://bitbucket.org/owner/repo/invalid/path')).toBe(false);
  });

  test('invalid GitLab URL', () => {
    expect(validateArchiveURL('https://gitlab.com/owner/repo/invalid/path')).toBe(false);
  });
});



---
File: /plugins/headlamp-plugin/src/additional.d.ts
---

/// <reference types="node" />
/// <reference types="react" />
/// <reference types="react-dom" />

declare namespace NodeJS {
  interface ProcessEnv {
    readonly NODE_ENV: 'development' | 'production' | 'test';
    readonly PUBLIC_URL: string;
  }
}

declare module '*.avif' {
  const src: string;
  export default src;
}

declare module '*.bmp' {
  const src: string;
  export default src;
}

declare module '*.gif' {
  const src: string;
  export default src;
}

declare module '*.jpg' {
  const src: string;
  export default src;
}

declare module '*.jpeg' {
  const src: string;
  export default src;
}

declare module '*.png' {
  const src: string;
  export default src;
}

declare module '*.webp' {
  const src: string;
  export default src;
}

declare module '*.svg' {
  const content: React.FunctionComponent<React.SVGAttributes<SVGElement>>;
  export default content;
}



---
File: /plugins/headlamp-plugin/src/ApiProxy.ts
---

export * from './lib/k8s/apiProxy';



---
File: /plugins/headlamp-plugin/src/CommonComponents.ts
---

export * from './components/common';



---
File: /plugins/headlamp-plugin/src/Crd.ts
---

export * from './lib/k8s/crd';
export { default } from './lib/k8s/crd';



---
File: /plugins/headlamp-plugin/src/index.ts
---

import { Theme } from '@mui/material/styles';

declare module '@mui/private-theming' {
  interface DefaultTheme extends Theme {}
}

import * as CommonComponents from './components/common';
import * as K8s from './lib/k8s';
import * as ApiProxy from './lib/k8s/apiProxy';
import * as Notification from './lib/notification';
import * as Router from './lib/router';
import * as Utils from './lib/util';
import { Headlamp, Plugin } from './plugin/lib';
import { PluginSettingsDetailsProps } from './plugin/pluginsSlice';
import Registry, {
  AppLogoProps,
  ClusterChooserProps,
  DefaultSidebars,
  DetailsViewDefaultHeaderActions,
  DetailsViewSectionProps,
  getHeadlampAPIHeaders,
  registerAppBarAction,
  registerAppLogo,
  registerClusterChooser,
  registerDetailsViewHeaderAction,
  registerDetailsViewHeaderActionsProcessor,
  registerDetailsViewSection,
  registerGetTokenFunction,
  registerPluginSettings,
  registerResourceTableColumnsProcessor,
  registerRoute,
  registerRouteFilter,
  registerSidebarEntry,
  registerSidebarEntryFilter,
} from './plugin/registry';

// We export k8s (lowercase) since someone may use it as we do in the Headlamp source code.
export {
  ApiProxy,
  K8s,
  K8s as k8s,
  CommonComponents,
  Utils,
  Router,
  Plugin,
  Registry,
  Headlamp,
  Notification,
  DetailsViewDefaultHeaderActions,
  getHeadlampAPIHeaders,
  registerAppLogo,
  registerAppBarAction,
  registerClusterChooser,
  registerDetailsViewHeaderAction,
  registerDetailsViewSection,
  registerRoute,
  registerRouteFilter,
  registerSidebarEntry,
  registerSidebarEntryFilter,
  registerDetailsViewHeaderActionsProcessor,
  registerGetTokenFunction,
  registerResourceTableColumnsProcessor,
  registerPluginSettings,
};

export type {
  AppLogoProps,
  PluginSettingsDetailsProps,
  ClusterChooserProps,
  DetailsViewSectionProps,
  DefaultSidebars,
};



---
File: /plugins/headlamp-plugin/src/Utils.ts
---

export * from './lib/util';



---
File: /plugins/headlamp-plugin/template/src/headlamp-plugin.d.ts
---

/// <reference types="@kinvolk/headlamp-plugin" />



---
File: /plugins/headlamp-plugin/dependencies-sync.js
---

#!/usr/bin/env node
// @ts-check
'use strict';

/*
 * # What is dependencies-sync.js for?
 *
 * Aids maintenance syncing packages between frontend/ and headlamp-plugin
 * Inside headlamp-plugin/ folder: `npm run update-dependencies`.
 *
 * This script is used to sync the dependencies between the frontend and headlamp-plugin.
 * It updates the dependencies from frontend/package.json into headlamp-plugin/packages.json.
 */

// Some packages are used by headlamp-plugin that are not used by the frontend.
// These won't be removed from headlamp-plugin/package.json
const dependenciesFrontDoesNotHave = new Set([
  'env-paths',
  'shx',
  'fs-extra',
  'validate-npm-package-name',
  'yargs',
  'vm-browserify',
  'table',
  'tar',
  'tmp',
  'vite-plugin-css-injected-by-js',
  'vite-plugin-static-copy',
]);

// Dependencies from frontend/package.json that aren't wanted by headlamp-plugin.
// These won't be added to headlamp-plugin/package.json
const dependenciesToNotCopy = [
  '@storybook/test',
  'husky',
  'typedoc',
  'typedoc-hugo-theme',
  'typedoc-plugin-markdown',
  'typedoc-plugin-rename-defaults',
];

const yargs = require('yargs/yargs');
const fs = require('fs-extra');
const headlampPluginPkg = require('./package.json');
const frontendPkg = require('../../frontend/package.json');

/**
 * Update dependencies from frontend/package.json into headlamp-plugin/packages.json
 *
 * Because frontend/ isn't distributed as a package, we can't just depend on it.
 *
 * @param packageJsonPath {string} where the package.json is
 * @param checkOnly {boolean} if true only do a check, do not
 * @rtype {boolean}
 * @returns 1 if something changed, 0 if nothing changed.
 */
function updateDependencies(packageJsonPath, checkOnly) {
  const allFrontendDependencies = {
    ...frontendPkg.dependencies,
    ...frontendPkg.devDependencies,
  };
  const newDependencies = {
    ...allFrontendDependencies,
    ...headlampPluginPkg.dependencies,
  };
  const headlampPluginPkgOriginal = { ...headlampPluginPkg };

  const sortedDependencies = {};
  Object.keys(newDependencies)
    .sort()
    .forEach(function (key) {
      sortedDependencies[key] = newDependencies[key];
    });

  // @ts-ignore because, the keys change in the dependencies.
  headlampPluginPkg.dependencies = sortedDependencies;

  // Some dependencies from frontend/ aren't wanted.
  for (const packageName of dependenciesToNotCopy) {
    delete headlampPluginPkg.dependencies[packageName];
  }

  // Check if dependenciesFrontDoesNotHave are also present here
  {
    const staleDeps = [];
    for (const packageName of dependenciesFrontDoesNotHave) {
      if (headlampPluginPkg.dependencies[packageName] === undefined) {
        staleDeps.push(packageName);
      }
    }
    if (staleDeps.length > 0) {
      console.log(
        `\nSTALE Dependencies. Both headlamp-plugin and front doesn't have them.\nRemove them from dependenciesFrontDoesNotHave in dedendencies-sync.js:\n`,
        staleDeps
      );
    }
  }

  // We want to find if packages are removed from frontend/package.json too.
  function checkRemovedDependencies(checkOnly) {
    // Are any in the output which aren't in the input anymore?
    function keysFromANotInB(a, b) {
      return Object.keys(a).filter(k => !(k in b));
    }

    const notIn = keysFromANotInB(headlampPluginPkg.dependencies, allFrontendDependencies).filter(
      k => !dependenciesFrontDoesNotHave.has(k)
    );

    for (const packageName of notIn) {
      delete headlampPluginPkg.dependencies[packageName];
    }

    if (notIn.length > 0) {
      if (checkOnly) {
        console.log(
          '\nDependencies REMOVED from frontend/ and should also be removed from headlamp-plugin/',
          notIn
        );
      } else {
        console.warn(
          '\nDependencies REMOVED from frontend/ and now also from headlamp-plugin/',
          notIn
        );
      }
      console.warn(
        'If you want to add these dependencies to headlamp-plugin, ' +
          'please add them to the dependenciesFrontDoesNotHave list inside dependencies-sync.js'
      );
    }
  }

  /**
   * The new dependencies which were added from frontend/ to headlamp-plugin/
   */
  function checkAddedDependencies(dependencies, dependenciesOriginal) {
    function keysFromANotInB(a, b) {
      return Object.keys(a).filter(k => !(k in b));
    }

    const notIn = keysFromANotInB(dependencies, dependenciesOriginal);

    if (notIn.length > 0) {
      console.log(
        'Dependencies ADDED to headlamp-plugin/package.json from frontend/package.json',
        notIn
      );
      console.warn(
        'If you want to prevent adding these dependencies to headlamp-plugin, ' +
          'please add them to the dependenciesToNotCopy list inside dependencies-sync.js'
      );
    }
  }

  /**
   * Check if the versions match, and if not sync the ones from frontend/ to headlamp-plugin/.
   *
   * @param dependencies {object} the dependencies from headlamp-plugin/package.json
   * @param dependenciesFront {object} the dependencies from frontend/package.json
   */
  function checkDependencyVersions(dependencies, dependenciesFront) {
    const changed = [];

    for (const [key, value] of Object.entries(dependencies)) {
      if (dependenciesFront[key] !== undefined && dependenciesFront[key] !== value) {
        changed.push({ name: key, frontend: dependenciesFront[key], headlampPlugin: value });
        dependencies[key] = dependenciesFront[key];
      }
    }

    if (changed.length > 0) {
      console.warn(
        'Dependencies with changed versions in headlamp-plugin/package.json from frontend/package.json',
        changed
      );
    }
  }

  checkRemovedDependencies(checkOnly);
  checkAddedDependencies(headlampPluginPkg.dependencies, headlampPluginPkgOriginal.dependencies);
  checkDependencyVersions(headlampPluginPkg.dependencies, allFrontendDependencies);

  const changed = JSON.stringify(headlampPluginPkgOriginal) !== JSON.stringify(headlampPluginPkg);

  if (checkOnly) {
    if (changed) {
      console.log('\nSome frontend/package.json dependencies changed.');
      console.log('Please run "npm run update-dependencies" to sync dependencies from frontend/.');
      return 1;
    } else {
      return 0;
    }
  }

  if (changed) {
    console.log(
      'Some frontend/package.json dependencies changed. Writing headlamp-plugin/package.json'
    );
    fs.writeFileSync(packageJsonPath, JSON.stringify(headlampPluginPkg, null, '  ') + '\n');
    return 1;
  } else {
    console.warn(
      'No frontend/package.json dependencies changed. Not writing headlamp-plugin/package.json'
    );
    return 0;
  }
}

/**
 * Update dependencies from frontend/package.json in headlamp-plugin/package.json
 *
 * @rtype {number}
 * @returns A return code, 0 if there is no problem, 1 if there is.
 */
function update() {
  updateDependencies('package.json', false);
  return 0;
}

/**
 * Check if dependencies changed
 *
 * @rtype {number}
 * @returns A return code, 1 if some do need updating, 0 if they don't
 */
function check() {
  return updateDependencies('package.json', true);
}

yargs(process.argv.slice(2))
  .command('check', 'Check if dependency updates are needed from frontend/package.json', {}, () => {
    process.exitCode = check();
  })
  .command(
    'update',
    'Update dependencies from frontend/package.json in headlamp-plugin/package.json',
    {},
    () => {
      process.exitCode = update();
    }
  )
  .demandCommand(1, '')
  .strict()
  .help().argv;



---
File: /plugins/headlamp-plugin/test-headlamp-plugin-published.js
---

#!/bin/env node
const USAGE = `
This tests a published @kinvolk/headlamp-plugin package.

./test-headlamp-plugin-published.js 0.5.2

Assumes being run within the plugins/headlamp-plugin folder
`;

function testHeadlampPluginPublished(pluginVersion) {
  run(`npm install @kinvolk/headlamp-plugin@${pluginVersion}`);

  run('npx @kinvolk/headlamp-plugin create headlamp-myfancy');

  curDir = path.join(tmpDir, 'headlamp-myfancy');
  // test headlamp-plugin build
  run('npm run build');
  checkFileExists(path.join(curDir, 'dist', 'main.js'));

  // test headlamp-plugin build folder
  curDir = tmpDir;
  fs.rmSync(path.join(tmpDir, 'headlamp-myfancy'), { recursive: true });
  run('npx @kinvolk/headlamp-plugin create headlamp-myfancy');
  run('npx @kinvolk/headlamp-plugin build headlamp-myfancy');
  checkFileExists(path.join(curDir, 'headlamp-myfancy', 'dist', 'main.js'));

  // test extraction works
  run('npx @kinvolk/headlamp-plugin extract ./ .plugins');
  checkFileExists(path.join(curDir, '.plugins', 'headlamp-myfancy', 'main.js'));
  // checkFileExists(path.join(curDir, '.plugins', 'headlamp-myfancy', 'package.json'));

  // test format command and that default code is formatted correctly
  fs.rmSync(path.join(tmpDir, 'headlamp-myfancy'), { recursive: true });
  run('npx @kinvolk/headlamp-plugin create headlamp-myfancy');
  curDir = path.join(tmpDir, 'headlamp-myfancy');
  run('npm run format');

  // test lint command and default code is lint free
  run('npm run lint');
  run('npm run lint-fix');

  // test type script error checks
  run('npm run tsc');
}

const fs = require('fs');
const os = require('os');
const child_process = require('child_process');
const path = require('path');
let tmpDir;
let curDir;

function cleanup() {
  console.log(`Cleaning up. Removing temp folder: "${tmpDir}"`);
  fs.rmSync(tmpDir, { recursive: true });
}

function run(cmd) {
  console.log('');
  console.log(`Running cmd:${cmd} inside of cwd:${curDir}`);
  console.log('');
  try {
    child_process.execSync(cmd, {
      stdio: 'inherit',
      cwd: curDir,
      encoding: 'utf8',
    });
  } catch (e) {
    console.error(`Error: Problem running "${cmd}" inside of "${curDir}"`);
    cleanup();
    process.exit(1);
  }
}
function checkFileExists(fname) {
  if (!fs.existsSync(fname)) {
    console.error(`Error: ${fname} does not exist.`);
    cleanup();
    process.exit(1);
  }
}

(function () {
  if (process.argv[1].includes('test-headlamp-plugin-published')) {
    const pluginVersion = process.argv[2];

    if (pluginVersion && process.argv[2] !== '--help') {
      console.log(`Testing pluginVersion: ${pluginVersion}`);
    } else {
      console.log('');
      console.log('pluginVersion as first argument required. Example: 0.5.2');
      console.log(USAGE);
      process.exit(1);
    }

    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'tmp-test-headlamp-plugin'));
    curDir = tmpDir;

    process.on('beforeExit', cleanup);
    testHeadlampPluginPublished(pluginVersion);
  }
})();



---
File: /plugins/headlamp-plugin/test-headlamp-plugin.js
---

#!/bin/env node
const USAGE = `
This tests unpublished @kinvolk/headlamp-plugin package in repo.

./test-headlamp-plugin.js

Assumes being run within the plugins/headlamp-plugin folder
`;
const PACKAGE_NAME = 'headlamp-myfancy';

function testHeadlampPlugin() {
  // remove some temporary files.
  cleanup();

  // Make a package file of headlamp-plugin we can test
  run('npm install');
  run('npm run build');
  run('npm pack');

  const packedFile = fs
    .readdirSync('.')
    .filter(file => file.match('kinvolk-headlamp-plugin-.*gz'))[0];
  console.log('Packed headlamp-plugin package file:', packedFile);

  // Use "link" to test the repo version of the headlamp-plugin tool.
  run('npm link');
  run(`node bin/headlamp-plugin.js create ${PACKAGE_NAME} --link`);
  curDir = join('.', PACKAGE_NAME);
  run(`npm install ${join('..', packedFile)}`);

  // test headlamp-plugin build
  run(`node ${join('..', 'bin', 'headlamp-plugin.js')} build`);
  checkFileExists(join(PACKAGE_NAME, 'dist', 'main.js'));

  // test headlamp-plugin build folder
  curDir = '.';
  fs.rmSync(PACKAGE_NAME, { recursive: true });
  run(`node bin/headlamp-plugin.js create ${PACKAGE_NAME} --link`);
  curDir = PACKAGE_NAME;
  run(`npm install ${join('..', packedFile)}`);
  curDir = '.';
  run(`node bin/headlamp-plugin.js build ${PACKAGE_NAME}`);
  checkFileExists(join(PACKAGE_NAME, 'dist', 'main.js'));

  fs.writeFileSync(join(PACKAGE_NAME, 'dist', 'extra.txt'), 'All dist/ files will be copied.');

  // test extraction works
  run(`node bin/headlamp-plugin.js extract . .plugins`);
  checkFileExists(join('.plugins', PACKAGE_NAME, 'main.js'));
  checkFileExists(join('.plugins', PACKAGE_NAME, 'package.json'));
  // make sure extra files in dist/ folder are copied too
  checkFileExists(join('.plugins', PACKAGE_NAME, 'extra.txt'));

  // test packing works
  const tmpDir = fs.mkdtempSync('headlamp-plugin-test-');
  run(`node bin/headlamp-plugin.js package ${PACKAGE_NAME} ${tmpDir}`);
  checkFileExists(join(tmpDir, `${PACKAGE_NAME}-0.1.0.tar.gz`));
  // extract archive and check files
  const extractionFolder = join(tmpDir, 'dst');
  fs.mkdirSync(extractionFolder, { recursive: true });
  run(`tar -xzf ${join(tmpDir, `${PACKAGE_NAME}-0.1.0.tar.gz`)} -C ${extractionFolder}`);
  checkFileExists(join(extractionFolder, `${PACKAGE_NAME}`, 'main.js'));
  checkFileExists(join(extractionFolder, `${PACKAGE_NAME}`, 'package.json'));
  fs.rmSync(tmpDir, { recursive: true });

  // test format command and that default code is formatted correctly
  fs.rmSync(PACKAGE_NAME, { recursive: true });
  run(`node bin/headlamp-plugin.js create ${PACKAGE_NAME} --link`);
  curDir = PACKAGE_NAME;
  run(`npm install ${join('..', packedFile)}`);
  run('npm run format');

  // test lint command and default code is lint free
  run('npm run lint');
  run('npm run lint-fix');

  // test type script error checks
  run('npm run tsc');

  // test the storybook builds
  // TODO: Reenable after storybook is fixed
  // run('npm run storybook-build');

  // test upgrade adds missing files
  const filesToRemove = [
    'tsconfig.json',
    join('src', 'headlamp-plugin.d.ts'),
    join('.vscode', 'extensions.json'),
  ];
  filesToRemove.forEach(file => {
    fs.rmSync(join(curDir, file), { recursive: true });
  });
  run(`node ${join('..', 'bin', 'headlamp-plugin.js')} upgrade --skip-package-updates`);
  checkFileExists(join(curDir, 'tsconfig.json'));
  checkFileExists(join(curDir, 'src', 'headlamp-plugin.d.ts'));
  checkFileExists(join(curDir, '.vscode', 'extensions.json'));

  // Does it upgrade "@kinvolk/headlamp-plugin" from an old version?
  // change @kinvolk/headlamp-plugin version in package.json to an old one "^0.4.9"
  const packageJsonPath = join(curDir, 'package.json');
  const packageJson = fs.readFileSync(packageJsonPath, 'utf8');
  const changedJson = packageJson
    .split('\n')
    .map(line =>
      line.includes('"@kinvolk/headlamp-plugin"')
        ? '    "@kinvolk/headlamp-plugin": "^0.4.9"\n'
        : line
    )
    .join('\n');
  fs.writeFileSync(packageJsonPath, changedJson);

  // test upgrade updates the package line, and the old version is not in there
  run(`node ${join('..', 'bin', 'headlamp-plugin.js')} upgrade`);
  const oldVersion = '0.4.9';
  if (fs.readFileSync(packageJsonPath, 'utf8').includes(oldVersion)) {
    exit(`Error: old version still in ${packageJsonPath}`);
  }

  // test there are no @material-ui imports, they should be mui
  if (fs.readFileSync(join(curDir, 'src', 'index.tsx'), 'utf8').includes('@material-ui')) {
    exit(`Error: @material-ui imports in ${mainJsPath}`);
  }
}

const fs = require('fs');
const child_process = require('child_process');
const path = require('path');
const join = path.join;
const resolve = path.resolve;
let curDir;

function cleanup() {
  console.log(`Cleaning up. Removing temp files...`);

  fs.readdirSync('.')
    .filter(file => file.match('kinvolk-headlamp-plugin-.*gz'))
    .forEach(file => fs.rmSync(file));

  const foldersToRemove = [path.join('.plugins', PACKAGE_NAME), PACKAGE_NAME];
  console.log('Temp foldersToRemove', foldersToRemove);
  foldersToRemove
    .filter(folder => fs.existsSync(folder))
    .forEach(folder => fs.rmSync(folder, { recursive: true }));
}

function run(cmd) {
  console.log('');
  console.log(`Running cmd:${cmd} inside of cwd:${curDir} abs: "${resolve(curDir)}"`);
  console.log('');
  try {
    child_process.execSync(cmd, {
      stdio: 'inherit',
      cwd: curDir,
      encoding: 'utf8',
    });
  } catch (e) {
    exit(`Error: Problem running "${cmd}" inside of "${curDir}" abs: "${resolve(curDir)}"`);
  }
}
function checkFileExists(fname) {
  if (!fs.existsSync(fname)) {
    exit(`Error: ${fname} does not exist.`);
  }
}
function exit(message) {
  console.error(message);
  cleanup();
  process.exit(1);
}

(function () {
  if (process.argv[1].includes('test-headlamp-plugin')) {
    console.log(USAGE);
    curDir = '.';

    process.on('beforeExit', cleanup);
    testHeadlampPlugin();
  }
})();


